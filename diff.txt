diff --git a/OldPDFViewer.tsx b/OldPDFViewer.tsx
deleted file mode 100644
index 3ed84c1..0000000
--- a/OldPDFViewer.tsx
+++ /dev/null
@@ -1,1343 +0,0 @@
-"use client";
-
-import React, { useState, useEffect, useRef } from "react";
-import { Viewer, Worker } from '@react-pdf-viewer/core';
-import { defaultLayoutPlugin } from '@react-pdf-viewer/default-layout';
-import { searchPlugin, SingleKeyword, Match } from '@react-pdf-viewer/search';
-import { highlightPlugin } from '@react-pdf-viewer/highlight';
-import { pageNavigationPlugin } from '@react-pdf-viewer/page-navigation';
-
-// Import styles
-import '@react-pdf-viewer/core/lib/styles/index.css';
-import '@react-pdf-viewer/default-layout/lib/styles/index.css';
-import '@react-pdf-viewer/search/lib/styles/index.css';
-import '@react-pdf-viewer/highlight/lib/styles/index.css';
-
-interface PDFViewerProps {
-  fileUrl: string
-  onPageChange?: (page: number) => void
-  currentPage?: number
-}
-
-const PDFViewer: React.FC<PDFViewerProps> = ({
-  fileUrl,
-  onPageChange,
-  currentPage = 1
-}) => {
-  const rootRef = useRef<HTMLDivElement | null>(null);
-  const [isDocLoaded, setIsDocLoaded] = useState(false);
-  const pendingNavRef = useRef<number | null>(null);
-  const lastKeywordsRef = useRef<SingleKeyword | SingleKeyword[] | undefined>(undefined);
-
-  const scrollToPageIndex = (zeroBasedIndex: number, attempts: number = 10) => {
-    if (attempts <= 0) return;
-    try {
-      // react-pdf-viewer sets data-testid="core__page-layer-{pageIndex}" where pageIndex is zero-based
-      const selectorByTestId = `[data-testid="core__page-layer-${zeroBasedIndex}"]`;
-      const el = document.querySelector(selectorByTestId) as HTMLElement | null;
-      const container = document.querySelector('[data-testid="core__inner-pages"]') as HTMLElement | null;
-      
-      // Safety check for DOM elements
-      if (!el || !container) {
-        console.log(`🔍 PDF: DOM elements not ready for page ${zeroBasedIndex}, attempt ${11 - attempts}/10`);
-        setTimeout(() => scrollToPageIndex(zeroBasedIndex, attempts - 1), 150);
-        return;
-      }
-      
-      if (el) {
-        if (container && typeof (container as any).scrollTo === 'function') {
-          try {
-            const contRect = container.getBoundingClientRect();
-            const pageRect = el.getBoundingClientRect();
-            const delta = (pageRect.top - contRect.top) + container.scrollTop;
-            // Align page near top with a small margin instead of centering
-            const targetTop = Math.max(0, delta - 24);
-            container.scrollTo({ top: targetTop, behavior: 'smooth' });
-          } catch (scrollError) {
-            console.warn("🔍 PDF: Smooth scroll failed, using fallback:", scrollError);
-            try {
-              const contRect = container.getBoundingClientRect();
-              const pageRect = el.getBoundingClientRect();
-              const delta = (pageRect.top - contRect.top) + container.scrollTop;
-              const targetTop = Math.max(0, delta - 24);
-              container.scrollTop = targetTop;
-            } catch (fallbackError) {
-              console.warn("🔍 PDF: Fallback scroll also failed:", fallbackError);
-            }
-          }
-        } else {
-          try {
-            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
-          } catch (scrollError) {
-            console.warn("🔍 PDF: scrollIntoView failed:", scrollError);
-          }
-        }
-        return;
-      }
-      
-      // Fallback to any future attribute we may support
-      const fallback = document.querySelector(`[data-page-number="${zeroBasedIndex + 1}"]`) as HTMLElement | null;
-      if (fallback && container) {
-        try {
-          if (typeof (container as any).scrollTo === 'function') {
-            const contRect = container.getBoundingClientRect();
-            const pageRect = fallback.getBoundingClientRect();
-            const delta = (pageRect.top - contRect.top) + container.scrollTop;
-            const targetTop = Math.max(0, delta - (container.clientHeight / 2) + (pageRect.height / 2));
-            container.scrollTo({ top: targetTop, behavior: 'smooth' });
-          } else {
-            fallback.scrollIntoView({ behavior: 'smooth', block: 'center' });
-          }
-        } catch (fallbackError) {
-          console.warn("🔍 PDF: Fallback navigation failed:", fallbackError);
-        }
-        return;
-      }
-    } catch (error) {
-      console.warn("🔍 PDF: Error in scrollToPageIndex:", error);
-    }
-    
-    // Retry with delay if elements aren't ready
-    setTimeout(() => scrollToPageIndex(zeroBasedIndex, attempts - 1), 150);
-  };
-  // Expose highlight API to global window for agent access
-  useEffect(() => {
-    if (typeof window !== 'undefined') {
-      window.pdfHighlighter = {
-        addHighlight: (highlight: any) => {
-          console.log("🎯 PDF API: Adding highlight:", highlight);
-          // This function is no longer used as we removed custom highlighting
-        },
-        removeHighlight: (id: string) => {
-          console.log("🎯 PDF API: Removing highlight:", id);
-          // This function is no longer used as we removed custom highlighting
-        },
-        clearHighlights: () => {
-          console.log("🎯 PDF API: Clearing all highlights and circles");
-          try {
-            if (searchPluginInstanceRef.current) {
-              searchPluginInstanceRef.current.clearHighlights();
-              console.log("🎯 PDF API: All highlights cleared successfully");
-            } else {
-              console.warn("🎯 PDF API: Search plugin not available for clearing highlights");
-            }
-          } catch (error) {
-            console.error("🎯 PDF API: Error clearing highlights/circles:", error);
-          }
-        },
-        goToPage: (pageNumber: number) => {
-          console.log("🎯 PDF API: Going to page:", pageNumber);
-          if (onPageChange) {
-            onPageChange(pageNumber);
-          }
-        },
-        searchAndHighlight: async (searchTerm: string, options: any) => {
-          console.log("🎯 PDF API: Searching for text:", searchTerm);
-          
-          if (!searchTerm || !searchPluginInstanceRef.current) {
-            console.warn("🎯 PDF API: Invalid search term or plugin not available");
-            if (options.onSearchComplete) {
-              options.onSearchComplete([]);
-            }
-            return;
-          }
-
-          try {
-            // Clear previous highlights first
-            searchPluginInstanceRef.current.clearHighlights();
-            
-            // Perform the actual search using react-pdf-viewer
-            const matches = await searchPluginInstanceRef.current.highlight([{
-              keyword: searchTerm,
-              matchCase: false
-            }]);
-            
-            console.log("🎯 PDF API: Real search results:", matches);
-            
-            // Convert matches to the expected format
-            const results = matches.map((match, index) => ({
-              text: searchTerm,
-              matchIndex: index,
-              pageIndex: match.pageIndex,
-              startIndex: match.startIndex,
-              endIndex: match.endIndex,
-              highlightAreas: [{
-                pageIndex: match.pageIndex,
-                left: 0, // react-pdf-viewer handles positioning internally
-                top: 0,
-                width: 100,
-                height: 2
-              }]
-            }));
-            
-            if (options.onSearchComplete) {
-              options.onSearchComplete(results);
-            }
-            
-            // Jump to first match if found
-            if (matches.length > 0) {
-              searchPluginInstanceRef.current.jumpToMatch(0);
-            }
-            
-          } catch (error) {
-            console.error("🎯 PDF API: Search failed:", error);
-            if (options.onSearchComplete) {
-              options.onSearchComplete([]);
-            }
-          }
-        }
-      };
-    }
-
-    return () => {
-      if (typeof window !== 'undefined') {
-        delete window.pdfHighlighter;
-      }
-    };
-  }, [onPageChange]);
-  // Listen for direct highlight events from agent (fallback)
-  useEffect(() => {
-    const handleNavigatePage = (event: any) => {
-      console.log("🧭 PDF: Received navigate page event:", event.detail);
-      const zeroBased = event.detail.pageNumber;
-      if (!isDocLoaded) {
-        pendingNavRef.current = zeroBased;
-        // Also store globally in case this component remounts
-        (window as any).__pendingPdfNav = zeroBased;
-        return;
-      }
-      try {
-        pageNavigationPluginInstance.jumpToPage(zeroBased);
-        // Avoid a second manual scroll; plugin handles positioning
-      } catch (e) {
-      if (onPageChange) {
-          onPageChange(zeroBased + 1);
-        }
-        scrollToPageIndex(zeroBased);
-      }
-    };
-
-    window.addEventListener('pdf-navigate-page', handleNavigatePage);
-
-    return () => {
-      window.removeEventListener('pdf-navigate-page', handleNavigatePage);
-    };
-  }, [onPageChange]);
-
-  // Create plugins (stable instance) with simple, clean highlighting
-  const searchPluginInstanceRef = useRef(searchPlugin({ 
-    enableShortcuts: true,
-    keyword: ''
-  }));
-  const searchPluginInstance = searchPluginInstanceRef.current;
-  const highlightPluginInstanceRef = useRef(highlightPlugin());
-  const highlightPluginInstance = highlightPluginInstanceRef.current;
-  const pageNavigationPluginInstanceRef = useRef(pageNavigationPlugin());
-  const pageNavigationPluginInstance = pageNavigationPluginInstanceRef.current;
-   // Use the default layout plugin with full controls
-  const defaultLayoutPluginInstance = useRef(defaultLayoutPlugin()).current;
-  
-  // Simplified highlighting/event wiring
-  useEffect(() => {
-    const SIMPLIFIED_VIEWER = true;
-    if (!SIMPLIFIED_VIEWER) return;
-    const sp = searchPluginInstanceRef.current;
-    if (!sp) return;
-    
-    const handleSearchRequest = async (event: any) => {
-      const requestId = event?.detail?.requestId;
-      const reqKeywords = event?.detail?.keywords as SingleKeyword | SingleKeyword[];
-      try {
-        await sp.clearHighlights();
-        if (!reqKeywords) {
-          window.dispatchEvent(new CustomEvent('pdf-search-results', { detail: { requestId, results: [] } }));
-          return;
-        }
-        const matches: any[] = await sp.highlight(reqKeywords as any);
-        const results = matches.map((m, i) => ({
-          pageIndex: m.pageIndex,
-          page: m.pageIndex + 1,
-          matchIndex: m.matchIndex,
-          startIndex: m.startIndex,
-          endIndex: m.endIndex,
-          excerpt: (m.pageText || '').slice(Math.max(0, m.startIndex - 80), Math.min((m.pageText || '').length, m.endIndex + 80)),
-          matchedText: (m.pageText || '').slice(m.startIndex, m.endIndex),
-          globalIndex: i,
-        }));
-        window.dispatchEvent(new CustomEvent('pdf-search-results', { detail: { requestId, results } }));
-      } catch (err) {
-        console.warn('PDF (simple) search failed:', err);
-        window.dispatchEvent(new CustomEvent('pdf-search-results', { detail: { requestId, results: [] } }));
-      }
-    };
-
-    const handleClear = () => {
-      try { sp.clearHighlights(); } catch {}
-    };
-
-    const handleQuote = async (event: any) => {
-      const text = String(event?.detail?.text || '').trim();
-      if (!text) return;
-      try {
-        await sp.clearHighlights();
-        await sp.highlight([{ keyword: text, matchCase: false }] as any);
-      } catch {}
-    };
-
-    window.addEventListener('pdf-search-request', handleSearchRequest);
-    window.addEventListener('pdf-clear-highlights', handleClear);
-    window.addEventListener('tutor-highlight-quote', handleQuote as EventListener);
-
-    return () => {
-      window.removeEventListener('pdf-search-request', handleSearchRequest);
-      window.removeEventListener('pdf-clear-highlights', handleClear);
-      window.removeEventListener('tutor-highlight-quote', handleQuote as EventListener);
-    };
-  }, [searchPluginInstanceRef.current]);
-  // Utility: find a text occurrence inside an element and return its DOMRange and page-relative rect
-  const normalizeSpaces = (s: string) => s.replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
-  const findTextRectInElement = (root: HTMLElement, term: string): { rect: DOMRect; range: Range } | null => {
-    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
-    const lowerTerm = normalizeSpaces(term.toLowerCase());
-    let node: Node | null = walker.nextNode();
-    while (node) {
-      const text = normalizeSpaces(node.nodeValue || '');
-      if (text) {
-        const idx = text.toLowerCase().indexOf(lowerTerm);
-        if (idx !== -1) {
-          try {
-            const range = document.createRange();
-            // Map idx back to original node offsets by scanning original string
-            const original = (node.nodeValue || '').replace(/\u00a0/g, ' ');
-            // Best effort: find the substring position ignoring repeated spaces
-            let oi = 0, ti = 0, start = -1, end = -1;
-            const target = lowerTerm;
-            const lowerOriginal = original.toLowerCase();
-            while (oi < lowerOriginal.length && ti < target.length) {
-              const oc = lowerOriginal[oi];
-              const tc = target[ti];
-              if (/\s/.test(oc) && /\s/.test(tc)) {
-                // consume contiguous spaces
-                while (oi < lowerOriginal.length && /\s/.test(lowerOriginal[oi])) oi++;
-                while (ti < target.length && /\s/.test(target[ti])) ti++;
-                if (start === -1) start = oi;
-                continue;
-              }
-              if (oc === tc) {
-                if (start === -1) start = oi;
-                oi++; ti++;
-              } else {
-                // Not matching, break
-                start = -1; end = -1; break;
-              }
-            }
-            if (start !== -1 && ti === target.length) {
-              end = oi;
-            } else {
-              start = idx; end = idx + lowerTerm.length;
-            }
-            range.setStart(node, Math.max(0, start));
-            range.setEnd(node, Math.min((node.nodeValue || '').length, end));
-            const rect = range.getBoundingClientRect();
-            return { rect, range };
-          } catch {}
-        }
-      }
-      node = walker.nextNode();
-    }
-    return null;
-  };
-
-  // Removed circle-by-text feature per request
-  useEffect(() => { return () => {}; }, []);
-
-  // Expose a stable global jump function for external callers (agent/session)
-  useEffect(() => {
-    if (typeof window === 'undefined') return;
-    const api: any = window as any;
-    api.pdfJumpToPage = (oneBasedPage: number) => {
-      const zeroBased = Math.max(0, (oneBasedPage || 1) - 1);
-      if (!isDocLoaded) {
-        pendingNavRef.current = zeroBased;
-        api.__pendingPdfNav = zeroBased;
-        return;
-      }
-      try {
-        pageNavigationPluginInstance.jumpToPage(zeroBased);
-      } catch {}
-      scrollToPageIndex(zeroBased);
-    };
-    
-    // Configure auto-advance settings
-    api.__pdfAutoAdvance = {
-      intervalMs: 3500,
-      enabled: true
-    };
-    
-    return () => {
-      try { delete (window as any).pdfJumpToPage; } catch {}
-    };
-  }, [isDocLoaded, pageNavigationPluginInstance]);
-
-  // Highlight queue to prevent conflicts
-  const highlightQueueRef = useRef<Array<{ requestId: string; keywords: any; timestamp: number }>>([]);
-  // Recent quote memory to prevent duplicate rapid highlights
-  const recentQuoteMemoRef = useRef<Array<{ key: string; at: number }>>([]);
-  const processingHighlightRef = useRef<boolean>(false);
-
-  const processHighlightQueue = async () => {
-    if (processingHighlightRef.current || highlightQueueRef.current.length === 0) {
-      return;
-    }
-
-    processingHighlightRef.current = true;
-    const currentRequest = highlightQueueRef.current.shift();
-    
-    if (!currentRequest) {
-      processingHighlightRef.current = false;
-      return;
-    }
-
-    const { requestId, keywords: reqKeywords } = currentRequest;
-    console.log("🔍 PDF: Processing highlight request:", { requestId, keywords: reqKeywords });
-
-    try {
-      // Only clear previous text highlights for non-quote operations to avoid flashing
-      const isQuoteHighlight = currentRequest.requestId.includes('quote-highlight');
-      if (!isQuoteHighlight && searchPluginInstanceRef.current) {
-        searchPluginInstanceRef.current.clearHighlights();
-        console.log("🔍 PDF: Previous highlights cleared (non-quote)");
-      } else {
-        console.log("🔍 PDF: Preserving existing highlights (quote highlight)");
-      }
-      
-      // Only clear circles for new search operations, not for quote highlighting
-      if (!isQuoteHighlight) {
-        console.log("🔍 PDF: Previous circles cleared (new search operation)");
-      } else {
-        console.log("🔍 PDF: Keeping circles visible (quote highlighting)");
-      }
-
-      // Small delay to ensure clearing is complete
-      await new Promise(resolve => setTimeout(resolve, 50));
-
-      if (!searchPluginInstanceRef.current) {
-        console.error("🔍 PDF: Search plugin instance not available");
-        return;
-      }
-      
-      const matches = await searchPluginInstanceRef.current.highlight(reqKeywords as any);
-      console.log("🔍 PDF: Real search results found:", matches.length, "matches");
-      
-      const results = matches.map((m, i) => {
-        const text = m.pageText || '';
-        const contextStart = Math.max(0, m.startIndex - 80);
-        const contextEnd = Math.min(text.length, m.endIndex + 80);
-        const excerpt = text.slice(contextStart, contextEnd);
-        const matchedText = text.slice(m.startIndex, m.endIndex);
-        
-        console.log(`🔍 PDF: Match ${i + 1} on page ${m.pageIndex + 1}: "${matchedText}" (${m.startIndex}-${m.endIndex})`);
-        
-        return {
-          pageIndex: m.pageIndex,
-          page: m.pageIndex + 1,
-          matchIndex: m.matchIndex,
-          globalIndex: i,
-          startIndex: m.startIndex,
-          endIndex: m.endIndex,
-          excerpt,
-          matchedText,
-        };
-      });
-      
-      console.log("🔍 PDF: Processed real search results:", results.length, "total matches");
-      window.dispatchEvent(new CustomEvent('pdf-search-results', {
-        detail: { requestId, results }
-      }));
-      
-    } catch (err) {
-      console.error('🔍 PDF: Search request failed', err);
-      window.dispatchEvent(new CustomEvent('pdf-search-results', {
-        detail: { requestId, results: [] }
-      }));
-    } finally {
-      processingHighlightRef.current = false;
-      // Process next item in queue after a small delay
-      setTimeout(processHighlightQueue, 100);
-    }
-  };
-
-  // Listen for search-related events from the agent/UI
-  useEffect(() => {
-    const handleSearchRequest = async (event: any) => {
-      const requestId = event?.detail?.requestId;
-      const reqKeywords = event?.detail?.keywords as SingleKeyword | SingleKeyword[];
-      console.log("🔍 PDF: Search request received and queued:", { requestId, keywords: reqKeywords });
-      console.log("🔍 PDF: Event detail:", event.detail);
-      
-      if (!reqKeywords) {
-        console.warn("🔍 PDF: No keywords provided for search");
-        return;
-      }
-      
-      // Add to queue instead of processing immediately
-      highlightQueueRef.current.push({
-        requestId,
-        keywords: reqKeywords,
-        timestamp: Date.now()
-      });
-      
-      // Start processing queue
-      processHighlightQueue();
-    };
-
-    const handleSetKeywords = async (event: any) => {
-      const newKeywords = event?.detail?.keywords as SingleKeyword | SingleKeyword[];
-      console.log("🔍 PDF: Setting keywords:", newKeywords);
-      lastKeywordsRef.current = newKeywords;
-      
-      // Also apply highlighting immediately when keywords are set
-      if (newKeywords && searchPluginInstanceRef.current) {
-        try {
-          console.log("🔍 PDF: Applying keywords for highlighting:", newKeywords);
-          await searchPluginInstanceRef.current.highlight(newKeywords as any);
-          console.log("🔍 PDF: Keywords applied successfully");
-        } catch (err) {
-          console.error("🔍 PDF: Failed to apply keywords:", err);
-        }
-      }
-    };
-
-    const handleJumpTo = (event: any) => {
-      const index = typeof event?.detail?.index === 'number' ? event.detail.index : 0;
-      let attempts = 0;
-      const tryJump = async () => {
-        try {
-          if (!searchPluginInstanceRef.current) {
-            console.error("🔍 PDF: Search plugin instance not available for jump");
-            return;
-          }
-          const result = searchPluginInstanceRef.current.jumpToMatch(index);
-          if (!result && attempts < 5) {
-            attempts += 1;
-            // Re-apply highlights if needed, then retry
-            const kw = lastKeywordsRef.current;
-            if (kw && searchPluginInstanceRef.current) {
-              try { await searchPluginInstanceRef.current.highlight(kw as any); } catch {}
-            }
-            setTimeout(tryJump, 150);
-          }
-        } catch (e) {
-          if (attempts < 5) {
-            attempts += 1;
-            const kw = lastKeywordsRef.current;
-            if (kw && searchPluginInstanceRef.current) {
-              try { await searchPluginInstanceRef.current.highlight(kw as any); } catch {}
-            }
-            setTimeout(tryJump, 150);
-          }
-        }
-      };
-      tryJump();
-    };
-
-    const handleClearHighlights = () => {
-      try { 
-        if (searchPluginInstanceRef.current) {
-          searchPluginInstanceRef.current.clearHighlights(); 
-        }
-        // Only clear circles if explicitly requested via 'tutor-annotations-clear' event
-        // Don't automatically clear circles with every highlight clear
-        console.log("🔍 PDF: Cleared highlights (circles preserved)");
-      } catch {}
-    };
-
-    window.addEventListener('pdf-search-request', handleSearchRequest);
-    window.addEventListener('pdf-set-keywords', handleSetKeywords);
-    window.addEventListener('pdf-jump-to', handleJumpTo);
-    window.addEventListener('pdf-clear-highlights', handleClearHighlights);
-
-    return () => {
-      window.removeEventListener('pdf-search-request', handleSearchRequest);
-      window.removeEventListener('pdf-set-keywords', handleSetKeywords);
-      window.removeEventListener('pdf-jump-to', handleJumpTo);
-      window.removeEventListener('pdf-clear-highlights', handleClearHighlights);
-    };
-  }, []);
-
-  // Listen for requests to circle a table label (e.g., "Table 1") and highlight quotes
-  useEffect(() => {
-    // Function to get actual table boundaries from PDF structure
-    const getTableBoundariesFromPDF = async (pageIndex: number, labelText: string) => {
-      try {
-        console.log(`🎯 Analyzing PDF structure for table: ${labelText} on page ${pageIndex + 1}`);
-        
-        // Access the PDF document from the viewer
-        const pdfDoc = (window as any).__pdfDocument;
-        if (!pdfDoc) {
-          console.log('🎯 PDF document not available for structure analysis');
-          return null;
-        }
-        
-        const page = await pdfDoc.getPage(pageIndex + 1);
-        const textContent = await page.getTextContent();
-        const viewport = page.getViewport({ scale: 1 });
-        
-        // Find the label position in the text content
-        let labelItem = null;
-        let labelIndex = -1;
-        
-        for (let i = 0; i < textContent.items.length; i++) {
-          const item = textContent.items[i];
-          if (item.str && item.str.toLowerCase().includes(labelText.toLowerCase())) {
-            labelItem = item;
-            labelIndex = i;
-            break;
-          }
-        }
-        
-        if (!labelItem) {
-          console.log('🎯 Label not found in PDF text content');
-          return null;
-        }
-        
-        console.log(`🎯 Found label at index ${labelIndex}:`, labelItem);
-        
-        // Analyze items after the label to find table structure
-        const tableItems = [];
-        const labelY = labelItem.transform[5]; // Y coordinate
-        const labelX = labelItem.transform[4]; // X coordinate
-        
-        // Look for structured content below the label
-        for (let i = labelIndex + 1; i < textContent.items.length; i++) {
-          const item = textContent.items[i];
-          const itemY = item.transform[5];
-          const itemX = item.transform[4];
-          
-          // Stop if we've moved too far down - tables are usually much closer
-          if (labelY - itemY > 100) break; // Much more restrictive: only 100 units below label
-          
-          // Much more restrictive: Only include actual table content
-          if (item.str && (
-            /^\d+\.?\d*$/.test(item.str.trim()) || // Pure numbers (table data)
-            /^[A-Z][a-z]+$/.test(item.str.trim()) || // Model names like "AED", "Transformer"
-            item.str.includes('M') || // Parameter counts like "116.2M"
-            /^[a-z]+$/.test(item.str.trim()) && item.str.length < 10 || // Short lowercase (like "clean", "test")
-            Math.abs(itemX - labelX) < 150 // Much closer horizontal alignment for table cells
-          )) {
-            tableItems.push({
-              text: item.str,
-              x: itemX,
-              y: itemY,
-              width: item.width || 0,
-              height: item.height || 0
-            });
-          }
-        }
-        
-        if (tableItems.length === 0) {
-          console.log('🎯 No table items found after label');
-          return null;
-        }
-        
-        // Calculate actual table boundaries
-        const minX = Math.min(labelX, ...tableItems.map(item => item.x));
-        const maxX = Math.max(labelX + (labelItem.width || 0), ...tableItems.map(item => item.x + item.width));
-        const minY = Math.min(labelY, ...tableItems.map(item => item.y));
-        const maxY = Math.max(labelY, ...tableItems.map(item => item.y));
-        
-        console.log(`🎯 PDF structure analysis - Table bounds: ${minX}, ${minY} to ${maxX}, ${maxY}`);
-        
-        return {
-          left: minX,
-          top: maxY, // PDF coordinates are flipped
-          right: maxX,
-          bottom: minY,
-          width: maxX - minX,
-          height: labelY - minY // Height in PDF coordinates
-        };
-        
-      } catch (error) {
-        console.error('🎯 Error analyzing PDF structure:', error);
-        return null;
-      }
-    };
-
-    const circleByLabel = (label: string) => {
-      console.log(`🎯 Circling label with PDF structure analysis: ${label}`);
-      
-      const requestId = `circle-${Date.now()}-${Math.random().toString(36).slice(2)}`;
-      const onResults = (e: any) => {
-        if (e?.detail?.requestId !== requestId) return;
-        window.removeEventListener('pdf-search-results', onResults as EventListener);
-        const results = (e?.detail?.results || []) as Array<{ pageIndex: number; matchIndex: number }>;
-        if (!results.length) {
-          console.log(`🎯 No search results found for label: ${label}`);
-          return;
-        }
-        
-        const first = results[0];
-        console.log(`🎯 Found label on page ${first.pageIndex + 1}, analyzing structure...`);
-        
-        setTimeout(async () => {
-          try {
-            const layer = document.querySelector(`[data-testid="core__page-layer-${first.pageIndex}"]`) as HTMLElement | null;
-            if (!layer) {
-              console.log(`🎯 Could not find page layer for page ${first.pageIndex}`);
-              return;
-            }
-
-            // Try PDF structure analysis first
-            const pdfBounds = await getTableBoundariesFromPDF(first.pageIndex, label);
-            if (pdfBounds) {
-              console.log(`🎯 Using PDF structure bounds:`, pdfBounds);
-              
-              // Convert PDF coordinates to screen coordinates
-              const layerRect = layer.getBoundingClientRect();
-              // For now, use a simple approach - just circle a reasonable area around the label
-              const hlEls = layer.querySelectorAll('.rpv-search__highlight');
-              if (hlEls && hlEls.length > 0) {
-                const firstHl = hlEls[0] as HTMLElement;
-                const hlRect = firstHl.getBoundingClientRect();
-                const labelLeft = hlRect.left - layerRect.left;
-                const labelTop = hlRect.top - layerRect.top;
-                
-                // Create a much smaller, more precise circle
-                const padding = 20;
-                const circleWidth = Math.min(300, layerRect.width * 0.4); // Max 300px or 40% of page
-                const circleHeight = Math.min(200, layerRect.height * 0.25); // Max 200px or 25% of page
-                
-              
-                console.log(`🎯 Drew precise table circle: ${circleWidth}x${circleHeight} at ${labelLeft}, ${labelTop}`);
-                return;
-              }
-            }
-            
-            const hlEls = layer.querySelectorAll('.rpv-search__highlight');
-            if (!hlEls || hlEls.length === 0) {
-              console.log(`🎯 No highlight elements found for ${label}`);
-              return;
-            }
-            
-            console.log(`🎯 Found ${hlEls.length} highlight elements`);
-            
-            const layerRect = layer.getBoundingClientRect();
-            let minLeft = Number.POSITIVE_INFINITY;
-            let minTop = Number.POSITIVE_INFINITY;
-            let maxRight = 0;
-            let maxBottom = 0;
-            
-            // Get bounds of all highlighted elements (the label)
-            hlEls.forEach((n) => {
-              const r = (n as HTMLElement).getBoundingClientRect();
-              minLeft = Math.min(minLeft, r.left);
-              minTop = Math.min(minTop, r.top);
-              maxRight = Math.max(maxRight, r.right);
-              maxBottom = Math.max(maxBottom, r.bottom);
-            });
-            
-            if (!isFinite(minLeft) || !isFinite(minTop)) return;
-            
-            // Convert to page-relative coordinates
-            const labelLeft = minLeft - layerRect.left;
-            const labelTop = minTop - layerRect.top;
-            const labelWidth = maxRight - minLeft;
-            const labelHeight = maxBottom - minTop;
-            
-            console.log(`🎯 Label bounds: ${labelLeft}, ${labelTop}, ${labelWidth}x${labelHeight}`);
-            
-            // Advanced content-aware circle positioning
-            const isTable = /table/i.test(label);
-            const isFigure = /figure/i.test(label);
-            
-            // Analyze content structure for 2-column layout
-            const analyzeContentBounds = () => {
-              // Get all text elements in the page layer
-              const textElements = Array.from(layer.querySelectorAll('span, div')).filter(el => {
-                const text = el.textContent?.trim();
-                return text && text.length > 0;
-              });
-              
-              if (textElements.length === 0) {
-                console.log('🎯 No text elements found for content analysis');
-                return null;
-              }
-              
-              // Improved 2-column detection by analyzing actual text distribution
-              const pageWidth = layerRect.width;
-              
-              // Analyze text distribution to find the actual column boundary
-              const textPositions = textElements.map(el => {
-                const rect = el.getBoundingClientRect();
-                return rect.left - layerRect.left;
-              }).sort((a, b) => a - b);
-              
-              // Find the gap between columns by looking for the largest horizontal gap
-              let columnBoundary = pageWidth / 2; // Default fallback
-              let maxGap = 0;
-              
-              for (let i = 1; i < textPositions.length; i++) {
-                const gap = textPositions[i] - textPositions[i-1];
-                if (gap > maxGap && gap > 30) { // Minimum gap of 30px to be considered column separator
-                  maxGap = gap;
-                  columnBoundary = textPositions[i-1] + gap / 2;
-                }
-              }
-              
-              // Determine which column the label is in based on detected boundary
-              const isLeftColumn = labelLeft < columnBoundary;
-              const columnStart = isLeftColumn ? 0 : columnBoundary;
-              const columnEnd = isLeftColumn ? columnBoundary : pageWidth;
-              
-              console.log(`🎯 Detected column boundary at ${columnBoundary.toFixed(1)}px`);
-              console.log(`🎯 Label in ${isLeftColumn ? 'LEFT' : 'RIGHT'} column (${columnStart.toFixed(1)}-${columnEnd.toFixed(1)})`);
-              
-              // Enhanced table/figure content detection for 2-column layout
-              const contentElements = textElements.filter(el => {
-                const rect = el.getBoundingClientRect();
-                const elTop = rect.top - layerRect.top;
-                const elLeft = rect.left - layerRect.left;
-                const elRight = elLeft + rect.width;
-                
-                // Check if element is in the same column
-                const elementInColumn = isLeftColumn ? 
-                  (elLeft >= columnStart && elLeft < columnEnd) :
-                  (elLeft >= columnStart && elLeft < layerRect.width);
-                
-                if (!elementInColumn) return false;
-                
-                // For tables, look for structured content (rows, cells, data)
-                if (isTable) {
-                  // Tables: look for content below the label (table rows/data)
-                  const isBelow = elTop >= labelTop - 20; // Allow slight overlap
-                  const horizontalOverlap = !(elRight < labelLeft - 100 || elLeft > labelLeft + labelWidth + 100);
-                  
-                  // Much more restrictive for tables - only include elements very close to the table
-                  const isVeryClose = (elTop - labelTop) < 200; // Reduced from 500 to 200
-                  const hasTableLikeContent = el.textContent && (
-                    /\d/.test(el.textContent) || // Contains numbers (common in tables)
-                    el.textContent.length < 50 || // Short text (table cells)
-                    /[|─┌┐└┘├┤┬┴┼]/.test(el.textContent) // Table drawing characters
-                  );
-                  
-                  return isBelow && horizontalOverlap && isVeryClose && hasTableLikeContent;
-                } else if (isFigure) {
-                  // Figures: look for content around the label (captions, figure content)
-                  const verticalDistance = Math.abs(elTop - labelTop);
-                  const horizontalDistance = Math.abs(elLeft - labelLeft);
-                  
-                  return verticalDistance < 300 && horizontalDistance < (pageWidth / 2) * 0.8;
-                } else {
-                  // Generic: nearby content
-                  const verticalDistance = Math.abs(elTop - labelTop);
-                  const horizontalDistance = Math.abs(elLeft - labelLeft);
-                  
-                  return verticalDistance < 200 && horizontalDistance < (pageWidth / 2) * 0.7;
-                }
-              });
-              
-              if (contentElements.length === 0) {
-                console.log('🎯 No content elements found near label in same column');
-                return null;
-              }
-              
-              console.log(`🎯 Found ${contentElements.length} content elements in same column`);
-              
-              // For tables, try to find the actual table bottom boundary
-              let tableBottomY = labelTop;
-              if (isTable && contentElements.length > 0) {
-                // Sort elements by vertical position to find table structure
-                const sortedElements = contentElements
-                  .map(el => {
-                    const rect = el.getBoundingClientRect();
-                    return {
-                      element: el,
-                      top: rect.top - layerRect.top,
-                      bottom: rect.top - layerRect.top + rect.height,
-                      left: rect.left - layerRect.left,
-                      text: el.textContent?.trim() || ''
-                    };
-                  })
-                  .sort((a, b) => a.top - b.top);
-                
-                // Look for table patterns: repeated horizontal structures, similar spacing
-                const rowElements = [];
-                let lastRowY = -1;
-                const rowSpacing = [];
-                
-                for (const elem of sortedElements) {
-                  if (elem.top > labelTop) { // Only consider elements below the label
-                    if (lastRowY >= 0) {
-                      const spacing = elem.top - lastRowY;
-                      rowSpacing.push(spacing);
-                    }
-                    rowElements.push(elem);
-                    lastRowY = elem.top;
-                  }
-                }
-                
-                // Find the consistent row spacing to detect table end
-                if (rowSpacing.length > 1) {
-                  const avgSpacing = rowSpacing.reduce((a, b) => a + b, 0) / rowSpacing.length;
-                  const lastElement = rowElements[rowElements.length - 1];
-                  
-                  // Look for where spacing becomes inconsistent (table ends)
-                  for (let i = rowSpacing.length - 1; i >= 0; i--) {
-                    if (Math.abs(rowSpacing[i] - avgSpacing) > avgSpacing * 0.5) {
-                      // Found inconsistent spacing - table likely ends here
-                      tableBottomY = rowElements[i].bottom;
-                      break;
-                    }
-                  }
-                  
-                  // If no inconsistency found, use the last element
-                  if (tableBottomY === labelTop && lastElement) {
-                    tableBottomY = lastElement.bottom;
-                  }
-                  
-                  console.log(`🎯 Table analysis: avgSpacing=${avgSpacing.toFixed(1)}, tableBottom=${tableBottomY.toFixed(1)}`);
-                }
-              }
-              
-              // Calculate the bounding box of all related content within the column
-              let minX = Number.POSITIVE_INFINITY;
-              let minY = Number.POSITIVE_INFINITY;
-              let maxX = 0;
-              let maxY = 0;
-              
-              contentElements.forEach(el => {
-                const rect = el.getBoundingClientRect();
-                const elLeft = rect.left - layerRect.left;
-                const elTop = rect.top - layerRect.top;
-                const elRight = elLeft + rect.width;
-                const elBottom = elTop + rect.height;
-                
-                minX = Math.min(minX, elLeft);
-                minY = Math.min(minY, elTop);
-                maxX = Math.max(maxX, elRight);
-                maxY = Math.max(maxY, elBottom);
-              });
-              
-              // For tables, extend the bottom boundary significantly to capture full table
-              if (isTable) {
-                const detectedBottom = tableBottomY > labelTop ? tableBottomY : maxY;
-                // Extend bottom boundary by additional amount to ensure full table capture
-                const extendedBottom = detectedBottom + 100; // Add 100px more to bottom
-                maxY = Math.max(maxY, extendedBottom);
-                console.log(`🎯 Extended table bottom from ${detectedBottom} to ${extendedBottom}`);
-              }
-              
-              // Include the original label in the bounds
-              minX = Math.min(minX, labelLeft);
-              minY = Math.min(minY, labelTop);
-              maxX = Math.max(maxX, labelLeft + labelWidth);
-              maxY = Math.max(maxY, labelTop + labelHeight);
-              
-              // Constrain to column boundaries
-              minX = Math.max(columnStart + 10, minX);
-              maxX = Math.min(columnEnd - 10, maxX);
-              
-              console.log(`🎯 2-column content analysis: ${minX}, ${minY} to ${maxX}, ${maxY}`);
-              
-              return {
-                left: minX,
-                top: minY,
-                width: maxX - minX,
-                height: maxY - minY,
-                isLeftColumn
-              };
-            };
-            
-            const contentBounds = analyzeContentBounds();
-            let circleLeft, circleTop, circleWidth, circleHeight;
-            
-            if (contentBounds) {
-              // Use the analyzed content bounds with appropriate padding
-              const padding = isTable ? 15 : isFigure ? 20 : 10;
-              
-              circleLeft = Math.max(0, contentBounds.left - padding);
-              circleTop = Math.max(0, contentBounds.top - padding);
-              circleWidth = Math.min(layerRect.width - circleLeft - padding, 
-                                   contentBounds.width + padding * 2);
-              circleHeight = Math.min(layerRect.height - circleTop - padding,
-                                    contentBounds.height + padding * 2);
-              
-              console.log(`🎯 Using content-based bounds with ${padding}px padding`);
-            } else {
-              // Fallback to improved heuristic approach
-              console.log('🎯 Using fallback heuristic approach');
-              
-              if (isTable) {
-                // Tables: moderate width, extend down from label
-                const padding = 20;
-                circleLeft = Math.max(0, labelLeft - padding);
-                circleTop = Math.max(0, labelTop - padding / 2);
-                circleWidth = Math.min(layerRect.width - circleLeft - padding,
-                                     Math.max(labelWidth + padding * 4, 300));
-                circleHeight = Math.min(layerRect.height - circleTop - padding, 150);
-              } else if (isFigure) {
-                // Figures: more square, centered around label
-                const padding = 25;
-                const estimatedWidth = Math.max(labelWidth + padding * 4, 250);
-                const estimatedHeight = Math.max(100, estimatedWidth * 0.7);
-                
-                circleLeft = Math.max(0, labelLeft - estimatedWidth / 4);
-                circleTop = Math.max(0, labelTop - padding);
-                circleWidth = Math.min(layerRect.width - circleLeft - padding, estimatedWidth);
-                circleHeight = Math.min(layerRect.height - circleTop - padding, estimatedHeight);
-              } else {
-                // Generic: tight around label with minimal padding
-                const padding = 15;
-                circleLeft = Math.max(0, labelLeft - padding);
-                circleTop = Math.max(0, labelTop - padding);
-                circleWidth = Math.min(layerRect.width - circleLeft, labelWidth + padding * 2);
-                circleHeight = Math.min(layerRect.height - circleTop, labelHeight + padding * 2);
-              }
-            }
-            
-            console.log(`🎯 Circle bounds: ${circleLeft}, ${circleTop}, ${circleWidth}x${circleHeight}`);
-            
-            drawCircleOnPage(first.pageIndex, {
-              left: circleLeft,
-              top: circleTop,
-              width: circleWidth,
-              height: circleHeight,
-            });
-            
-            console.log(`🎯 Successfully circled ${label} on page ${first.pageIndex + 1}`);
-          } catch (error) {
-            console.error(`🎯 Error circling ${label}:`, error);
-          }
-        }, 120);
-      };
-      
-      window.addEventListener('pdf-search-results', onResults as EventListener, { once: true });
-      // Clear existing circles before creating new ones (but only for circle operations)
-      try { clearAllCircles(); } catch {}
-      
-      // Enhanced search with multiple variations of the label
-      const searchTerms = [label];
-      
-      // Add variations for better matching
-      if (label.toLowerCase().includes('table')) {
-        const num = label.match(/\d+/)?.[0];
-        if (num) {
-          searchTerms.push(`Table ${num}`);
-          searchTerms.push(`table ${num}`);
-          searchTerms.push(`TABLE ${num}`);
-        }
-      } else if (label.toLowerCase().includes('figure')) {
-        const num = label.match(/\d+/)?.[0];
-        if (num) {
-          searchTerms.push(`Figure ${num}`);
-          searchTerms.push(`figure ${num}`);
-          searchTerms.push(`FIGURE ${num}`);
-          searchTerms.push(`Fig. ${num}`);
-          searchTerms.push(`fig. ${num}`);
-        }
-      }
-      
-      console.log(`🎯 Searching for label variations:`, searchTerms);
-      
-      window.dispatchEvent(new CustomEvent('pdf-search-request', {
-        detail: { requestId, keywords: searchTerms }
-      }));
-    };
-
-    // Quote highlighting removed per request
-
-    const handleCircleTable = (event: any) => {
-      const label = String(event?.detail?.label || '').trim() || 'Table 1';
-      // Try to jump to the first detected page quickly once results return; circleByLabel will handle drawing
-      circleByLabel(label);
-    };
-    const handleCircleFigure = (event: any) => {
-      const label = String(event?.detail?.label || '').trim() || 'Figure 1';
-      circleByLabel(label);
-    };
-    const handleClearAnnotations = () => { try { clearAllBrackets(); } catch {} };
-
-    // Bracket a section across a page range (inclusive indices)
-    const handleBracketSectionRange = (e: any) => {
-      const start: number = Math.max(0, parseInt(String(e?.detail?.startPageIndex ?? 0), 10));
-      const end: number = Math.max(start, parseInt(String(e?.detail?.endPageIndex ?? start), 10));
-      const attempts = 8;
-      const drawForPage = (pi: number, tries: number) => {
-        const ok = drawBracketsOnPage(pi);
-        if (!ok && tries > 0) setTimeout(() => drawForPage(pi, tries - 1), 200);
-      };
-      for (let pi = start; pi <= end; pi++) drawForPage(pi, attempts);
-    };
-    // Bracket only the specific section's vertical span within a page
-    const handleBracketSection = (e: any) => {
-      const pageIndex: number = Math.max(0, parseInt(String(e?.detail?.pageIndex ?? 0), 10));
-      const topRatio: number = Math.max(0, Math.min(1, Number(e?.detail?.topRatio ?? 0)));
-      const bottomRatio: number = Math.max(topRatio, Math.min(1, Number(e?.detail?.bottomRatio ?? 1)));
-      const attempts = 8;
-      const draw = (tries: number) => {
-        const ok = drawBracketsOnPageSegment(pageIndex, { topRatio, bottomRatio });
-        if (!ok && tries > 0) setTimeout(() => draw(tries - 1), 200);
-      };
-      draw(attempts);
-    };
-
-    window.addEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener);
-    window.addEventListener('tutor-bracket-section-range', handleBracketSectionRange as EventListener);
-    window.addEventListener('tutor-bracket-section', handleBracketSection as EventListener);
-    
-    return () => {
-      window.removeEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener);
-      window.removeEventListener('tutor-bracket-section-range', handleBracketSectionRange as EventListener);
-      window.removeEventListener('tutor-bracket-section', handleBracketSection as EventListener);
-    };
-  }, []);
-
-  // React to keyword changes (only clear when empty; highlighting is driven by explicit requests)
-  useEffect(() => {
-    const hasNoKeywords =
-      lastKeywordsRef.current === undefined ||
-      (Array.isArray(lastKeywordsRef.current) && lastKeywordsRef.current.length === 0) ||
-      (typeof lastKeywordsRef.current === 'string' && lastKeywordsRef.current.trim() === '');
-
-    if (hasNoKeywords) {
-      try {
-        searchPluginInstanceRef.current.clearHighlights();
-        console.log("🔍 PDF: Cleared highlights due to no keywords");
-      } catch {}
-    }
-  }, [lastKeywordsRef.current]);
-
-  return (
-    <div ref={rootRef} className="w-full h-full">
-      {/* Removed circle and custom highlight styling */}
-      <Worker workerUrl="/pdf.worker.js">
-        <div style={{ height: '100%' }}>
-          <Viewer
-            fileUrl={fileUrl}
-            plugins={[defaultLayoutPluginInstance, pageNavigationPluginInstance, searchPluginInstance, highlightPluginInstance]}
-            onDocumentLoad={(e) => {
-              setIsDocLoaded(true);
-              try {
-                (window as any).__pdfNumPages = e?.doc?.numPages ?? undefined;
-                window.dispatchEvent(new CustomEvent('pdf-doc-loaded', { detail: { numPages: e?.doc?.numPages } }));
-              } catch {}
-              // Signal readiness for external controllers
-              try {
-                (window as any).__pdfReady = true;
-                window.dispatchEvent(new CustomEvent('pdf-ready'));
-              } catch {}
-              // Extract outline (sections) and expose globally
-              (async () => {
-                try {
-                  console.log("🔍 PDF: Attempting to extract outline...");
-                  
-                  // Try multiple methods to get the outline
-                  let outline: any[] = [];
-                  
-                  // Method 1: Try getOutline()
-                  try {
-                    outline = await (e as any)?.doc?.getOutline?.();
-                    console.log("🔍 PDF: getOutline() result:", outline);
-                  } catch (err) {
-                    console.log("🔍 PDF: getOutline() failed:", err);
-                  }
-                  
-                  // Method 2: Try bookmarks if outline failed
-                  if (!outline || outline.length === 0) {
-                    try {
-                      outline = await (e as any)?.doc?.getBookmarks?.();
-                      console.log("🔍 PDF: getBookmarks() result:", outline);
-                    } catch (err) {
-                      console.log("🔍 PDF: getBookmarks() failed:", err);
-                    }
-                  }
-                  
-                  // Method 3: Try to extract from document info
-                  if (!outline || outline.length === 0) {
-                    try {
-                      const info = await (e as any)?.doc?.getMetadata?.();
-                      console.log("🔍 PDF: Document metadata:", info);
-                    } catch (err) {
-                      console.log("🔍 PDF: getMetadata() failed:", err);
-                    }
-                  }
-                  
-                  const flat: Array<{ title: string; pageIndex: number }> = [];
-                  if (Array.isArray(outline) && outline.length > 0) {
-                    const walk = async (items: any[]) => {
-                      for (const it of items) {
-                        let pageIndex: number | null = null;
-                        const dest = it?.dest;
-                        if (Array.isArray(dest) && dest[0]) {
-                          try { pageIndex = await (e as any).doc.getPageIndex(dest[0]); } catch {}
-                        }
-                        if (typeof pageIndex === 'number') {
-                          flat.push({ title: String(it.title || '').trim(), pageIndex });
-                        }
-                        if (Array.isArray(it.items) && it.items.length) {
-                          await walk(it.items);
-                        }
-                      }
-                    };
-                    await walk(outline);
-                  }
-                  
-                  console.log("🔍 PDF: Final extracted sections:", flat);
-                  (window as any).__pdfOutline = flat;
-                  window.dispatchEvent(new CustomEvent('pdf-outline', { detail: { sections: flat } }));
-                  
-                  // Also try to extract section-like content from page text
-                  if (flat.length === 0) {
-                    console.log("🔍 PDF: No outline found, attempting to extract sections from page text...");
-                    try {
-                      const numPages = e?.doc?.numPages || 0;
-                      const textSections: Array<{ title: string; pageIndex: number }> = [];
-                      const seen = new Set<string>();
-                      const maxPages = Math.min(numPages, 30);
-                      
-                      const pushSection = (rawTitle: string, pageIdx: number) => {
-                        const title = String(rawTitle || '').replace(/\s+/g, ' ').trim();
-                        if (!title) return;
-                        const key = `${pageIdx}:${title.toLowerCase()}`;
-                        if (seen.has(key)) return;
-                        seen.add(key);
-                        textSections.push({ title, pageIndex: pageIdx });
-                      };
-                      
-                      for (let i = 0; i < maxPages; i++) {
-                        try {
-                          const page = await (e as any).doc.getPage(i + 1);
-                          const textContent = await page.getTextContent();
-                          const items = (textContent.items || []) as any[];
-                          
-                          // Group by visual line using Y coordinate (transform[5]) and keep an estimated font size per line
-                          const linesMap = new Map<number, { y: number; parts: string[]; maxSize: number }>();
-                          const allSizes: number[] = [];
-                          for (const it of items) {
-                            const str = String(it?.str || '').trim();
-                            if (!str) continue;
-                            const y = Math.round(Number(it?.transform?.[5] ?? 0));
-                            const a = Number(it?.transform?.[0] ?? 0);
-                            const d = Number(it?.transform?.[3] ?? 0);
-                            const estSize = Math.max(0, Math.sqrt(a * a + d * d));
-                            allSizes.push(estSize);
-                            if (!linesMap.has(y)) linesMap.set(y, { y, parts: [], maxSize: 0 });
-                            const rec = linesMap.get(y) as any;
-                            rec.parts.push(str);
-                            if (estSize > rec.maxSize) rec.maxSize = estSize;
-                          }
-                          const median = (() => {
-                            if (allSizes.length === 0) return 0;
-                            const s = allSizes.slice().sort((x, y) => x - y);
-                            const mid = Math.floor(s.length / 2);
-                            return s.length % 2 ? s[mid] : (s[mid - 1] + s[mid]) / 2;
-                          })();
-                          
-                          const lines = Array.from(linesMap.values())
-                            .sort((a, b) => b.y - a.y)
-                            .map((l) => ({ text: l.parts.join(' ').replace(/\s+/g, ' ').trim(), size: l.maxSize }))
-                            .filter((l) => !!l.text);
-                          
-                          // Heuristics for headings
-                          const isTitleCase = (s: string) => {
-                            // at least two words start with capital and not ALL CAPS paragraphs
-                            const words = s.split(/\s+/);
-                            const capsStart = words.filter((w) => /^[A-Z][A-Za-z0-9\-]*$/.test(w)).length;
-                            return capsStart >= Math.min(2, Math.ceil(words.length * 0.5));
-                          };
-                          const isAllCapsShort = (s: string) => /^(?:[A-Z0-9][A-Z0-9\-]*\s*){1,8}$/.test(s);
-                          const wordCount = (s: string) => s.split(/\s+/).filter(Boolean).length;
-                          const numOnly = /^\d+(?:\.\d+)*$/;
-                          const numWithTitle = /^\d+(?:\.\d+)*\s+.+/;
-                          const namedSections = /^(Abstract|Introduction|Background|Related\s+Work|Methods?|Approach|Experiments?|Results|Discussion|Conclusions?|References|Appendix|Baselines?)\b/i;
-                          const tableFigure = /^(Table|Figure)\s+\d+[A-Za-z]?\b/i;
-                          
-                          for (let li = 0; li < lines.length; li++) {
-                            const { text: line, size } = lines[li];
-                            if (!line) continue;
-                            
-                            // 1) Number-only heading: try to merge with nearby title line (next or previous)
-                            if (numOnly.test(line)) {
-                              const next = lines[li + 1]?.text || '';
-                              const prev = lines[li - 1]?.text || '';
-                              const candidate = isTitleCase(next) ? next : (isTitleCase(prev) ? prev : '');
-                              if (candidate) {
-                                pushSection(`${line} ${candidate}`, i);
-                              } else {
-                                pushSection(line, i);
-                              }
-                              continue;
-                            }
-                            
-                            // 2) Number with title on same line
-                            if (numWithTitle.test(line)) {
-                              pushSection(line, i);
-                              continue;
-                            }
-                            
-                            // 3) Canonical named sections
-                            if (namedSections.test(line)) {
-                              pushSection(line, i);
-                              continue;
-                            }
-                            
-                            // 4) Table/Figure labels
-                            if (tableFigure.test(line)) {
-                              pushSection(line, i);
-                              continue;
-                            }
-                            
-                            // 5) Font-size based heading heuristic
-                            const wc = wordCount(line);
-                            const looksHeading = (size > median * 1.15) && wc > 0 && wc <= 12 && (isTitleCase(line) || isAllCapsShort(line));
-                            if (looksHeading) {
-                              pushSection(line, i);
-                              continue;
-                            }
-                          }
-                        } catch (err) {
-                          console.log(`🔍 PDF: Failed to extract text from page ${i + 1}:`, err);
-                        }
-                      }
-                      
-                      if (textSections.length > 0) {
-                        console.log("🔍 PDF: Found sections from text extraction:", textSections);
-                        (window as any).__pdfOutline = textSections;
-                        window.dispatchEvent(new CustomEvent('pdf-outline', { detail: { sections: textSections } }));
-                      }
-                    } catch (err) {
-                      console.log("🔍 PDF: Text-based section extraction failed:", err);
-                    }
-                  }
-                } catch (err) {
-                  console.log("🔍 PDF: Outline extraction completely failed:", err);
-                }
-              })();
-              if (pendingNavRef.current !== null) {
-                try {
-                  pageNavigationPluginInstance.jumpToPage(pendingNavRef.current);
-                } catch {}
-                scrollToPageIndex(pendingNavRef.current ?? 0);
-                pendingNavRef.current = null;
-              }
-              // Apply any globally-persisted pending nav
-              const globalPending = (window as any).__pendingPdfNav;
-              if (typeof globalPending === 'number') {
-                try { pageNavigationPluginInstance.jumpToPage(globalPending); } catch {}
-                scrollToPageIndex(globalPending ?? 0);
-                (window as any).__pendingPdfNav = null;
-              }
-            }}
-            onPageChange={(e) => {
-              if (onPageChange) {
-                onPageChange(e.currentPage + 1); // Convert back to 1-based
-              }
-            }}
-          />
-        </div>
-      </Worker>
-    </div>
-  );
-};
-
-export default PDFViewer;
diff --git a/match.js b/match.js
deleted file mode 100644
index 23372ac..0000000
--- a/match.js
+++ /dev/null
@@ -1,13 +0,0 @@
-import matchText from './matchText.json' assert { type: 'json' };
-
-
-
-let ms = matchText.matches[0];
-console.log(ms);
-let mx  = Object.assign({}, {excerpt: ms.excerpt});
-
-
-
-
-
-    
\ No newline at end of file
diff --git a/matchText.json b/matchText.json
deleted file mode 100644
index 496f9a4..0000000
--- a/matchText.json
+++ /dev/null
@@ -1,42 +0,0 @@
-{
-    "success": true,
-    "query": "Recurrent neural networks",
-    "matches": [
-        {
-            "pageIndex": 0,
-            "page": 1,
-            "matchIndex": 0,
-            "globalIndex": 0,
-            "startIndex": 1307,
-            "endIndex": 1332,
-            "excerpt": "peech, statespace model, attention-free, transformer, stateformer1. IntroductionRecurrent neural networks (RNNs) have historically been a coreapproach for a wide range of sequence model",
-            "matchedText": "Recurrent neural networks"
-        },
-        {
-            "pageIndex": 4,
-            "page": 5,
-            "matchIndex": 0,
-            "globalIndex": 1,
-            "startIndex": 2939,
-            "endIndex": 2964,
-            "excerpt": "i´c, and C. Eliasmith, “Legendre memory units:Continuous-time representation in recurrent neural networks,” inConference on Neural Information Processing Systems, 2019.[16] T. Lei, Y. Z",
-            "matchedText": "recurrent neural networks"
-        }
-    ],
-    "pages": [
-        1,
-        5
-    ],
-    "citations": [
-        {
-            "page": 1,
-            "quote": "peech, statespace model, attention-free, transformer, stateformer1. IntroductionRecurrent neural networks (RNNs) have historically been a co"
-        },
-        {
-            "page": 5,
-            "quote": "i´c, and C. Eliasmith, “Legendre memory units:Continuous-time representation in recurrent neural networks,” inConference on Neural Informati"
-        }
-    ],
-    "message": "Found 2 matches for \"Recurrent neural networks\" across pages 1, 5."
-}
-
diff --git a/package.json b/package.json
index 459b157..eca7336 100644
--- a/package.json
+++ b/package.json
@@ -5,9 +5,8 @@
   "engines": {
     "node": "20.x"
   },
-  "type": "module",
   "scripts": {
-    "dev": "npm run copy-pdf-worker && next dev",
+    "dev": "npm run copy-pdf-worker && next dev --turbopack",
     "build": "npm run copy-pdf-worker && prisma generate && next build",
     "start": "next start",
     "postinstall": "prisma generate",
@@ -23,7 +22,7 @@
   },
   "dependencies": {
     "@auth/core": "^0.40.0",
-    "@auth/prisma-adapter": "1.3.0",
+    "@auth/prisma-adapter": "^2.10.0",
     "@jchaffin/pdf-parse": "^1.1.1",
     "@openai/agents": "^0.0.11",
     "@prisma/client": "^6.14.0",
@@ -34,8 +33,6 @@
     "@react-pdf-viewer/highlight": "^3.12.0",
     "@react-pdf-viewer/page-navigation": "3.12.0",
     "@react-pdf-viewer/search": "^3.12.0",
-    "@simplewebauthn/browser": "9.0.1",
-    "@simplewebauthn/server": "9.0.3",
     "@types/jsonwebtoken": "^9.0.10",
     "@vercel/blob": "^0.22.3",
     "ai": "^4.0.17",
@@ -68,7 +65,6 @@
     "@types/uuid": "^10.0.0",
     "eslint": "^9",
     "eslint-config-next": "15.4.6",
-    "prettier": "^3.6.2",
     "prisma": "^6.14.0",
     "tailwindcss": "^4",
     "typescript": "^5"
diff --git a/src/app/api/documents/[id]/embeddings/route.ts b/src/app/api/documents/[id]/embeddings/route.ts
deleted file mode 100644
index 673d298..0000000
--- a/src/app/api/documents/[id]/embeddings/route.ts
+++ /dev/null
@@ -1,63 +0,0 @@
-import { NextRequest, NextResponse } from 'next/server'
-import { auth } from '@/lib/auth'
-import { prisma } from '@/lib/prisma'
-import { extractTextFromPDF } from '@/lib/pdfUtils'
-import { openai } from '@/lib/openai'
-
-function chunkText(text: string, opts?: { chunkSize?: number; overlap?: number }): string[] {
-  const chunkSize = Math.max(400, Math.min(1200, opts?.chunkSize ?? 800))
-  const overlap = Math.max(0, Math.min(chunkSize - 50, opts?.overlap ?? 120))
-  const cleaned = text.replace(/\s+/g, ' ').trim()
-  const chunks: string[] = []
-  for (let i = 0; i < cleaned.length; i += (chunkSize - overlap)) {
-    const slice = cleaned.slice(i, i + chunkSize).trim()
-    if (slice.length > 50) chunks.push(slice)
-    if (i + chunkSize >= cleaned.length) break
-  }
-  return chunks
-}
-
-export async function POST(
-  request: NextRequest,
-  { params }: { params: Promise<{ id: string }> }
-) {
-  const { id } = await params
-  try {
-    const session = await auth()
-    if (!session?.user?.id) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
-
-    const doc = await prisma.document.findFirst({ where: { id, userId: session.user.id } })
-    if (!doc) return NextResponse.json({ error: 'Document not found' }, { status: 404 })
-
-    const extraction = await extractTextFromPDF(doc.filepath || '')
-    const pdfText = extraction?.text || ''
-    if (!pdfText) return NextResponse.json({ message: 'No text extracted' })
-
-    const chunks = chunkText(pdfText)
-    if (chunks.length === 0) return NextResponse.json({ message: 'No chunks' })
-
-    const emb = await openai.embeddings.create({ model: 'text-embedding-3-small', input: chunks })
-    const vectors = emb.data.map((d) => d.embedding as number[])
-
-    // Upsert chunks
-    for (let i = 0; i < chunks.length; i++) {
-      await prisma.documentChunk.upsert({
-        where: { documentId_idx: { documentId: doc.id, idx: i } as any },
-        update: { text: chunks[i], embedding: vectors[i] as unknown as any },
-        create: {
-          documentId: doc.id,
-          idx: i,
-          text: chunks[i],
-          embedding: vectors[i] as unknown as any,
-        },
-      } as any)
-    }
-
-    return NextResponse.json({ success: true, chunks: chunks.length })
-  } catch (e) {
-    console.error('Embeddings build error:', e)
-    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
-  }
-}
-
-
diff --git a/src/app/api/documents/[id]/route.ts b/src/app/api/documents/[id]/route.ts
index 135ea53..8dd6f55 100644
--- a/src/app/api/documents/[id]/route.ts
+++ b/src/app/api/documents/[id]/route.ts
@@ -48,52 +48,3 @@ export async function GET(
     )
   }
 }
-
-export async function PATCH(
-  request: NextRequest,
-  { params }: { params: Promise<{ id: string }> }
-) {
-  const { id } = await params
-  try {
-    const session = await auth()
-    if (!session?.user?.id) {
-      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
-    }
-
-    const { title } = await request.json().catch(() => ({})) as { title?: string }
-    if (!title || !title.trim()) {
-      return NextResponse.json({ error: 'Title is required' }, { status: 400 })
-    }
-
-    const doc = await prisma.document.findFirst({ where: { id, userId: session.user.id } })
-    if (!doc) return NextResponse.json({ error: 'Document not found' }, { status: 404 })
-
-    const updated = await prisma.document.update({ where: { id }, data: { title: title.trim() } })
-    return NextResponse.json({ id: updated.id, title: updated.title })
-  } catch (error) {
-    console.error('Error updating document title:', error)
-    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
-  }
-}
-
-export async function DELETE(
-  request: NextRequest,
-  { params }: { params: Promise<{ id: string }> }
-) {
-  const { id } = await params
-  try {
-    const session = await auth()
-    if (!session?.user?.id) {
-      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
-    }
-
-    const doc = await prisma.document.findFirst({ where: { id, userId: session.user.id } })
-    if (!doc) return NextResponse.json({ error: 'Document not found' }, { status: 404 })
-
-    await prisma.document.delete({ where: { id } })
-    return NextResponse.json({ success: true })
-  } catch (error) {
-    console.error('Error deleting document:', error)
-    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
-  }
-}
diff --git a/src/app/api/documents/[id]/similarity/route.ts b/src/app/api/documents/[id]/similarity/route.ts
deleted file mode 100644
index 02f1034..0000000
--- a/src/app/api/documents/[id]/similarity/route.ts
+++ /dev/null
@@ -1,158 +0,0 @@
-import { NextRequest, NextResponse } from 'next/server'
-import { auth } from '@/lib/auth'
-import { prisma } from '@/lib/prisma'
-import { extractTextFromPDF } from '@/lib/pdfUtils'
-import { openai } from '@/lib/openai'
-
-type Embed = number[]
-
-function cosineSimilarity(a: Embed, b: Embed): number {
-  let dot = 0
-  let na = 0
-  let nb = 0
-  for (let i = 0; i < a.length && i < b.length; i++) {
-    const x = a[i]
-    const y = b[i]
-    dot += x * y
-    na += x * x
-    nb += y * y
-  }
-  const denom = Math.sqrt(na) * Math.sqrt(nb) || 1
-  return dot / denom
-}
-
-function chunkText(text: string, opts?: { chunkSize?: number; overlap?: number }): string[] {
-  const chunkSize = Math.max(400, Math.min(1200, opts?.chunkSize ?? 800))
-  const overlap = Math.max(0, Math.min(chunkSize - 50, opts?.overlap ?? 120))
-  const cleaned = cleanText(text)
-  const chunks: string[] = []
-  for (let i = 0; i < cleaned.length; i += (chunkSize - overlap)) {
-    const slice = cleaned.slice(i, i + chunkSize).trim()
-    if (slice.length > 50) chunks.push(slice)
-    if (i + chunkSize >= cleaned.length) break
-  }
-  return chunks
-}
-
-function cleanText(t: string): string {
-  return (t || '')
-    // normalize fancy quotes/dashes
-    .replace(/[\u2018\u2019\u201A\u201B]/g, "'")
-    .replace(/[\u201C\u201D\u201E\u201F]/g, '"')
-    .replace(/[\u2013\u2014]/g, '-')
-    // collapse hyphenation across line breaks
-    .replace(/-\s*\n\s*/g, '')
-    .replace(/\s*\n\s*/g, ' ')
-    .replace(/\s+/g, ' ')
-    .trim()
-}
-
-function splitSentences(t: string): string[] {
-  const cleaned = cleanText(t)
-  // basic sentence split
-  const parts = cleaned.split(/(?<=[.!?])\s+(?=[A-Z0-9\(\[])/)
-  return parts
-    .map((s) => s.trim())
-    .filter((s) => s.length >= 40 && s.length <= 400)
-    .filter((s) => {
-      const letters = (s.match(/[A-Za-z]/g) || []).length
-      return letters / Math.max(1, s.length) >= 0.5
-    })
-}
-
-export async function POST(
-  request: NextRequest,
-  { params }: { params: Promise<{ id: string }> }
-) {
-  const { id } = await params
-  try {
-    const session = await auth()
-    if (!session?.user?.id) {
-      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
-    }
-
-    const { text, topK = 3 } = await request.json().catch(() => ({})) as { text?: string; topK?: number }
-    if (!text || typeof text !== 'string' || text.trim().length < 4) {
-      return NextResponse.json({ error: 'Text is required' }, { status: 400 })
-    }
-
-    const doc = await prisma.document.findFirst({ where: { id, userId: session.user.id } })
-    if (!doc) return NextResponse.json({ error: 'Document not found' }, { status: 404 })
-
-    // Get full text from PDF (from blob url saved as filepath)
-    // Prefer stored embeddings
-    let stored: Array<{ text: string; embedding: number[] }> = []
-    const hasChunks = Boolean((prisma as any)?.documentChunk?.findMany)
-    if (hasChunks) {
-      try {
-        const rows = await (prisma as any).documentChunk.findMany({
-          where: { documentId: doc.id },
-          orderBy: { idx: 'asc' }
-        })
-        stored = rows as any
-      } catch (e) {
-        console.warn('Similarity: stored embeddings query failed, falling back')
-      }
-    }
-
-    let snippets: Array<{ snippet: string; score: number }> = []
-    if (stored.length > 0) {
-      const trimmed = text.trim()
-      if (!trimmed) return NextResponse.json({ snippets: [] })
-      const emb = await openai.embeddings.create({ model: 'text-embedding-3-small', input: [trimmed] })
-      const queryVec = emb.data?.[0]?.embedding as Embed
-      if (!queryVec) return NextResponse.json({ snippets: [] })
-      const chunkScores = stored.map((c) => ({ text: cleanText(c.text), score: cosineSimilarity(queryVec, (c.embedding || []) as unknown as Embed) }))
-      chunkScores.sort((a, b) => b.score - a.score)
-      const topChunks = chunkScores.slice(0, Math.max(1, Math.min(5, topK)))
-      // Build candidate sentences from top chunks
-      const sentences = topChunks.flatMap((c) => splitSentences(c.text))
-      if (sentences.length === 0) {
-        snippets = topChunks.map(({ text: t, score }) => ({ snippet: t.slice(0, 300), score }))
-      } else {
-        // Embed query + sentences and select best sentences
-        const inputs = [trimmed, ...sentences]
-        const emb2 = await openai.embeddings.create({ model: 'text-embedding-3-small', input: inputs })
-        const qv = emb2.data[0].embedding as Embed
-        const sentVecs = emb2.data.slice(1).map((d) => d.embedding as Embed)
-        const scoredSents = sentences.map((s, i) => ({ snippet: s, score: cosineSimilarity(qv, sentVecs[i]) }))
-        scoredSents.sort((a, b) => b.score - a.score)
-        snippets = scoredSents.slice(0, Math.max(1, Math.min(10, topK))).map((s) => ({ snippet: s.snippet, score: s.score }))
-      }
-    } else {
-      // Fallback to on-the-fly
-      const extraction = await extractTextFromPDF(doc.filepath || '')
-      const pdfText = extraction?.text ? cleanText(extraction.text) : ''
-      if (!pdfText) return NextResponse.json({ snippets: [], message: 'No text extracted' })
-      const chunks = chunkText(pdfText)
-      const q = text.trim()
-      if (!q) return NextResponse.json({ snippets: [] })
-      const inputs = [q, ...chunks]
-      const emb = await openai.embeddings.create({ model: 'text-embedding-3-small', input: inputs })
-      const queryVec = emb.data?.[0]?.embedding as Embed
-      const chunkVecs = emb.data.slice(1).map(e => (e.embedding || []) as Embed)
-      const chunkScores = chunks.map((c, i) => ({ text: c, score: cosineSimilarity(queryVec, chunkVecs[i]) }))
-      chunkScores.sort((a, b) => b.score - a.score)
-      const topChunks = chunkScores.slice(0, Math.max(1, Math.min(5, topK)))
-      const sentences = topChunks.flatMap((c) => splitSentences(c.text))
-      if (sentences.length === 0) {
-        snippets = topChunks.map(({ text: t, score }) => ({ snippet: t.slice(0, 300), score }))
-      } else {
-        const inputs2 = [q, ...sentences]
-        const emb2 = await openai.embeddings.create({ model: 'text-embedding-3-small', input: inputs2 })
-        const qv = emb2.data[0].embedding as Embed
-        const sentVecs = emb2.data.slice(1).map((d) => d.embedding as Embed)
-        const scoredSents = sentences.map((s, i) => ({ snippet: s, score: cosineSimilarity(qv, sentVecs[i]) }))
-        scoredSents.sort((a, b) => b.score - a.score)
-        snippets = scoredSents.slice(0, Math.max(1, Math.min(10, topK))).map((s) => ({ snippet: s.snippet, score: s.score }))
-      }
-    }
-
-    return NextResponse.json({ snippets })
-  } catch (error) {
-    console.error('Similarity API error:', error)
-    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
-  }
-}
-
-
diff --git a/src/app/api/documents/route.ts b/src/app/api/documents/route.ts
index 32c7f4f..c631b5b 100644
--- a/src/app/api/documents/route.ts
+++ b/src/app/api/documents/route.ts
@@ -18,7 +18,6 @@ export async function GET(request: NextRequest) {
         id: true,
         title: true,
         filename: true,
-        filepath: true,
         createdAt: true,
       },
       orderBy: {
diff --git a/src/app/api/session/route.ts b/src/app/api/session/route.ts
index 70c7836..f4e983d 100644
--- a/src/app/api/session/route.ts
+++ b/src/app/api/session/route.ts
@@ -19,7 +19,6 @@ export async function POST() {
       return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });
     }
 
-    const model = process.env.OPENAI_REALTIME_MODEL || 'gpt-4o-realtime-preview';
     const response = await fetch('https://api.openai.com/v1/realtime/sessions', {
       method: 'POST',
       headers: {
@@ -27,7 +26,7 @@ export async function POST() {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify({
-        model,
+        model: 'gpt-4o-realtime-preview-2025-06-03',
       }),
     });
 
diff --git a/src/app/api/upload/route.ts b/src/app/api/upload/route.ts
index 844e2fe..22bd089 100644
--- a/src/app/api/upload/route.ts
+++ b/src/app/api/upload/route.ts
@@ -6,7 +6,6 @@ export const runtime = 'nodejs'
 export const dynamic = 'force-dynamic'
 export const maxDuration = 60
 import { randomUUID } from 'crypto'
-import { extractTextFromPDF } from '@/lib/pdfUtils'
 
 export async function POST(request: NextRequest) {
   try {
@@ -49,32 +48,10 @@ export async function POST(request: NextRequest) {
       token: process.env.BLOB_READ_WRITE_TOKEN,
     })
 
-    // After upload, extract title via pdfUtils from the blob URL
-    let extractedTitle: string | undefined
-    try {
-      const extraction = await extractTextFromPDF(blob.url)
-      extractedTitle = extraction.title
-    } catch {}
-
-    // Generate a readable fallback title from the filename if extraction failed
-    const generateTitleFromFilename = (raw: string): string => {
-      const withoutExt = raw.replace(/\.[^.]+$/i, '')
-      const cleaned = withoutExt
-        .replace(/[_-]+/g, ' ') // underscores/dashes to spaces
-        .replace(/\s+/g, ' ') // collapse spaces
-        .trim()
-      // Title-case words up to a reasonable length
-      const words = cleaned.split(' ').slice(0, 16)
-      const titled = words
-        .map((w) => (w.length === 0 ? w : w[0].toUpperCase() + w.slice(1)))
-        .join(' ')
-      return titled.substring(0, 120)
-    }
-
-    // Save document metadata to database (use extracted title if available)
+    // Save document metadata to database
     const document = await prisma.document.create({
       data: {
-        title: (extractedTitle && extractedTitle.trim()) || generateTitleFromFilename(file.name),
+        title: file.name.replace('.pdf', ''),
         filename: file.name,
         filepath: blob.url,
         mimeType: file.type,
@@ -83,22 +60,6 @@ export async function POST(request: NextRequest) {
       }
     })
 
-    // Kick off embeddings build for semantic highlighting
-    try {
-      const origin = new URL(request.url).origin
-      // Fire-and-forget; do not block upload response
-      fetch(`${origin}/api/documents/${document.id}/embeddings`, { method: 'POST' })
-        .then(async (res) => {
-          if (!res.ok) {
-            const t = await res.text().catch(() => '')
-            console.error('Embeddings build failed:', res.status, t)
-          }
-        })
-        .catch((e) => console.error('Embeddings build error:', e))
-    } catch (e) {
-      console.error('Embeddings trigger error:', e)
-    }
-
     return NextResponse.json({
       message: 'File uploaded successfully',
       documentId: document.id
diff --git a/src/app/auth/signin/page.tsx b/src/app/auth/signin/page.tsx
index 03dd1c6..68193fc 100644
--- a/src/app/auth/signin/page.tsx
+++ b/src/app/auth/signin/page.tsx
@@ -4,7 +4,6 @@ import { useState } from 'react'
 import { signIn, getSession } from 'next-auth/react'
 import { useRouter } from 'next/navigation'
 import Link from 'next/link'
-import { Button } from '@/components/ui/Button'
 
 export default function SignIn() {
   const [email, setEmail] = useState('')
@@ -42,36 +41,34 @@ export default function SignIn() {
   }
 
   return (
-    <div className="min-h-screen bg-white flex items-center justify-center p-6">
-      <form onSubmit={handleSubmit} className="w-full max-w-sm space-y-5">
-        <h1 className="text-2xl font-semibold text-center text-slate-900">Sign in</h1>
-        <div className="text-center text-xs text-slate-600">Test user: <span className="font-medium">test@test.com</span> / <span className="font-medium">test</span></div>
+    <div className="min-h-screen flex items-center justify-center p-4">
+      <form onSubmit={handleSubmit} className="w-full max-w-sm space-y-4">
+        <h1 className="text-xl font-semibold text-center">Sign in</h1>
+        <div className="text-center text-sm text-gray-600">Demo: test@test.com / test</div>
 
         <div className="space-y-1">
-          <label htmlFor="email" className="block text-sm text-slate-700">Email</label>
+          <label htmlFor="email" className="block text-sm">Email</label>
           <input
             id="email"
             name="email"
             type="email"
             autoComplete="email"
             required
-            className="w-full border border-slate-300 rounded px-3 py-2 focus:outline-none focus:ring-2"
-            style={{ outline: 'none', boxShadow: '0 0 0 0px transparent' }}
+            className="w-full border rounded px-3 py-2"
             value={email}
             onChange={(e) => setEmail(e.target.value)}
           />
         </div>
 
         <div className="space-y-1">
-          <label htmlFor="password" className="block text-sm text-slate-700">Password</label>
+          <label htmlFor="password" className="block text-sm">Password</label>
           <input
             id="password"
             name="password"
             type="password"
             autoComplete="current-password"
             required
-            className="w-full border border-slate-300 rounded px-3 py-2 focus:outline-none focus:ring-2"
-            style={{ outline: 'none', boxShadow: '0 0 0 0px transparent' }}
+            className="w-full border rounded px-3 py-2"
             value={password}
             onChange={(e) => setPassword(e.target.value)}
           />
@@ -79,19 +76,12 @@ export default function SignIn() {
 
         {error && <div className="text-red-600 text-sm text-center">{error}</div>}
 
-        <Button
-          type="submit"
-          disabled={loading}
-          className="w-full rounded-full"
-        >
+        <button type="submit" disabled={loading} className="w-full border rounded px-3 py-2 bg-black text-white disabled:opacity-50">
           {loading ? 'Signing in…' : 'Sign in'}
-        </Button>
+        </button>
 
-        <div className="text-center text-sm text-slate-700">
-          Don&apos;t have an account?{' '}
-          <Link href="/auth/signup" className="underline" style={{ color: 'var(--brand-start)' }}>
-            Sign up
-          </Link>
+        <div className="text-center text-sm">
+          Don&apos;t have an account? <Link href="/auth/signup" className="underline">Sign up</Link>
         </div>
       </form>
     </div>
diff --git a/src/app/dashboard/page.tsx b/src/app/dashboard/page.tsx
index fb90d64..19e83ee 100644
--- a/src/app/dashboard/page.tsx
+++ b/src/app/dashboard/page.tsx
@@ -5,16 +5,10 @@ import { useRouter } from 'next/navigation'
 import { useEffect, useState } from 'react'
 import Link from 'next/link'
 
-interface RenameState {
-  id: string
-  title: string
-}
-
 interface Document {
   id: string
   title: string
   filename: string
-  filepath?: string
   createdAt: string
 }
 
@@ -23,10 +17,6 @@ export default function Dashboard() {
   const router = useRouter()
   const [documents, setDocuments] = useState<Document[]>([])
   const [loading, setLoading] = useState(true)
-  const [menuOpenId, setMenuOpenId] = useState<string | null>(null)
-  const [rename, setRename] = useState<RenameState | null>(null)
-  const [deletingId, setDeletingId] = useState<string | null>(null)
-  const [userMenuOpen, setUserMenuOpen] = useState<boolean>(false)
 
   useEffect(() => {
     if (status === 'unauthenticated') {
@@ -54,56 +44,6 @@ export default function Dashboard() {
     }
   }
 
-  const handleRename = (doc: Document) => {
-    setRename({ id: doc.id, title: doc.title })
-    setMenuOpenId(null)
-  }
-
-  const submitRename = async () => {
-    if (!rename) return
-    const { id, title } = rename
-    const newTitle = title.trim()
-    if (!newTitle) return
-    // optimistic update
-    setDocuments(prev => prev.map(d => (d.id === id ? { ...d, title: newTitle } : d)))
-    try {
-      const res = await fetch(`/api/documents/${id}`, {
-        method: 'PATCH',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ title: newTitle })
-      })
-      if (!res.ok) throw new Error('Failed to rename')
-    } catch (e) {
-      // revert by refetching on error
-      await fetchDocuments()
-      console.error(e)
-    } finally {
-      setRename(null)
-    }
-  }
-
-  const handleDelete = (doc: Document) => {
-    setDeletingId(doc.id)
-    setMenuOpenId(null)
-  }
-
-  const confirmDelete = async () => {
-    if (!deletingId) return
-    const id = deletingId
-    // optimistic removal
-    setDocuments(prev => prev.filter(d => d.id !== id))
-    try {
-      const res = await fetch(`/api/documents/${id}`, { method: 'DELETE' })
-      if (!res.ok) throw new Error('Failed to delete')
-    } catch (e) {
-      console.error(e)
-      // refetch to restore
-      await fetchDocuments()
-    } finally {
-      setDeletingId(null)
-    }
-  }
-
   if (status === 'loading') {
     return (
       <div className="min-h-screen flex items-center justify-center">
@@ -117,156 +57,75 @@ export default function Dashboard() {
   }
 
   return (
-    <>
-    <div className="min-h-screen bg-white text-slate-900">
+    <div className="min-h-screen bg-gray-50">
       {/* Header */}
-      <header className="sticky top-0 z-30 border-b bg-white">
+      <header className="bg-white shadow-sm border-b">
         <div className="container mx-auto px-4 py-4 flex justify-between items-center">
-          <h1 className="text-2xl font-extrabold text-slate-900">
-            AI <span className="text-[var(--brand)]">Tutor</span>
+          <h1 className="text-2xl font-bold text-gray-900">
+            AI <span className="text-indigo-600">Tutor</span>
           </h1>
           <div className="flex items-center gap-4">
-            <div className="relative">
-              <button
-                className="secondary-btn px-3 py-2 rounded-full flex items-center gap-2 cursor-pointer"
-                onClick={() => setUserMenuOpen(!userMenuOpen)}
-                aria-haspopup="menu"
-                aria-expanded={userMenuOpen}
-              >
-                <span className="inline-flex h-6 w-6 items-center justify-center rounded-full bg-[var(--brand)] text-white text-xs">
-                  {(session?.user?.name || session?.user?.email || 'TU').split(' ').map(s => s[0]).slice(0,2).join('').toUpperCase()}
-                </span>
-                <span className="hidden sm:inline text-slate-700">{session?.user?.name || session?.user?.email || 'Test User'}</span>
-                <span className="text-slate-500">▾</span>
-              </button>
-              {userMenuOpen && (
-                <div className="absolute right-0 mt-2 w-44 rounded-xl border bg-white shadow-md z-50">
-                  <Link href="/dashboard" className="block px-3 py-2 hover:bg-slate-50 cursor-pointer">Dashboard</Link>
-                  <Link href="/upload" className="block px-3 py-2 hover:bg-slate-50 cursor-pointer">Upload</Link>
-                  <Link href="/tutor" className="block px-3 py-2 hover:bg-slate-50 cursor-pointer">Chat History</Link>
-                  <button className="w-full text-left px-3 py-2 hover:bg-slate-50 cursor-pointer" onClick={() => signOut()}>Sign out</button>
-                </div>
-              )}
-            </div>
+            <span className="text-gray-600">Welcome, {session?.user?.name || session?.user?.email}</span>
+            <button
+              onClick={() => signOut()}
+              className="text-gray-600 hover:text-gray-900 transition-colors cursor-pointer"
+            >
+              Sign Out
+            </button>
           </div>
         </div>
       </header>
 
-      <div className="container mx-auto px-4 py-10">
+      <div className="container mx-auto px-4 py-8">
         <div className="flex justify-between items-center mb-8">
-          <h2 className="text-3xl font-bold text-slate-900">Your Documents</h2>
-          <Link href="/upload" className="primary-btn px-6 py-2 font-semibold">
+          <h2 className="text-3xl font-bold text-gray-900">Your Documents</h2>
+          <Link
+            href="/upload"
+            className="bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700 transition-colors"
+          >
             Upload PDF
           </Link>
         </div>
 
         {loading ? (
           <div className="text-center py-8">
-            <div className="text-lg text-slate-600">Loading documents...</div>
+            <div className="text-lg text-gray-600">Loading documents...</div>
           </div>
         ) : documents.length > 0 ? (
           <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
             {documents.map((doc) => (
               <div
                 key={doc.id}
-                className="card-glass p-4 rounded-2xl hover:shadow-lg transition-shadow cursor-pointer"
+                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer"
                 onClick={() => router.push(`/tutor/${doc.id}`)}
               >
-                <div className="flex items-start gap-3">
-                  <div className="flex-1 min-w-0">
-                    <div className="w-full aspect-[4/3] overflow-hidden rounded-xl border bg-slate-50">
-                      {doc.filepath ? (
-                        <object data={`${doc.filepath}#page=1`} type="application/pdf" className="w-full h-full pointer-events-none" aria-label="PDF preview" />
-                      ) : (
-                        <div className="w-full h-full" />
-                      )}
-                    </div>
-                    <h3 className="mt-3 font-semibold text-slate-900 line-clamp-2 break-words">
-                      {doc.title}
-                    </h3>
-                    <p className="text-xs text-slate-500 mt-1">Uploaded {new Date(doc.createdAt).toLocaleDateString()}</p>
-                  </div>
-                  <div className="relative">
-                    <button
-                      className="px-2 py-1 text-slate-600 hover:text-slate-900 cursor-pointer"
-                      onClick={(e) => { e.stopPropagation(); setMenuOpenId(menuOpenId === doc.id ? null : doc.id) }}
-                      aria-label="Document actions"
-                    >
-                      ⋮
-                    </button>
-                    {menuOpenId === doc.id && (
-                      <div className="absolute right-0 mt-2 w-40 rounded-xl border bg-white shadow-md z-10">
-                        <button
-                          className="w-full text-left px-3 py-2 hover:bg-slate-50 cursor-pointer"
-                          onClick={(e) => { e.stopPropagation(); router.push(`/tutor/${doc.id}`) }}
-                        >
-                          Open
-                        </button>
-                        <button
-                          className="w-full text-left px-3 py-2 hover:bg-slate-50 cursor-pointer"
-                          onClick={(e) => { e.stopPropagation(); handleRename(doc) }}
-                        >
-                          Rename
-                        </button>
-                        <button
-                          className="w-full text-left px-3 py-2 text-red-600 hover:bg-red-50 cursor-pointer"
-                          onClick={(e) => { e.stopPropagation(); handleDelete(doc) }}
-                        >
-                          Remove
-                        </button>
-                      </div>
-                    )}
+                <div className="flex items-center mb-4">
+                  <div className="text-red-500 text-2xl mr-3">📄</div>
+                  <div>
+                    <h3 className="font-semibold text-gray-900 truncate">{doc.title}</h3>
+                    <p className="text-sm text-gray-500">{doc.filename}</p>
                   </div>
                 </div>
+                <div className="text-xs text-gray-400">
+                  Uploaded {new Date(doc.createdAt).toLocaleDateString()}
+                </div>
               </div>
             ))}
           </div>
         ) : (
           <div className="text-center py-16">
-            <div className="text-6xl text-slate-400 mb-4">📚</div>
-            <h3 className="text-xl font-semibold text-slate-900 mb-2">No documents yet</h3>
-            <p className="text-slate-600 mb-6">Upload your first PDF to start learning with AI</p>
-            <Link href="/upload" className="primary-btn px-6 py-2 font-semibold">
+            <div className="text-6xl text-gray-300 mb-4">📚</div>
+            <h3 className="text-xl font-semibold text-gray-700 mb-2">No documents yet</h3>
+            <p className="text-gray-500 mb-6">Upload your first PDF to start learning with AI</p>
+            <Link
+              href="/upload"
+              className="bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700 transition-colors"
+            >
               Upload Your First PDF
             </Link>
           </div>
         )}
       </div>
     </div>
-
-    {/* Rename Modal */}
-    {rename && (
-      <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/20">
-        <div className="bg-white rounded-2xl shadow-lg w-full max-w-md p-6">
-          <h4 className="text-lg font-semibold text-slate-900 mb-2">Rename document</h4>
-          <input
-            className="w-full border rounded-xl px-3 py-2 outline-none focus:ring-2 focus:ring-[var(--brand)]"
-            value={rename?.title ?? ''}
-            onChange={(e) => setRename((prev) => (prev ? { ...prev, title: e.target.value } : prev))}
-            onKeyDown={(e) => { if (e.key === 'Enter') submitRename() }}
-            aria-label="Document title"
-          />
-          <div className="mt-4 flex justify-end gap-2">
-            <button className="px-4 py-2 rounded-full border cursor-pointer" onClick={() => setRename(null)}>Cancel</button>
-            <button className="primary-btn px-4 py-2 rounded-full" onClick={submitRename}>Save</button>
-          </div>
-        </div>
-      </div>
-    )}
-
-    {/* Delete Confirm */}
-    {deletingId && (
-      <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/20">
-        <div className="bg-white rounded-2xl shadow-lg w-full max-w-md p-6">
-          <h4 className="text-lg font-semibold text-slate-900 mb-2">Remove document?</h4>
-          <p className="text-slate-600">This will delete the document permanently.</p>
-          <div className="mt-4 flex justify-end gap-2">
-            <button className="px-4 py-2 rounded-full border cursor-pointer" onClick={() => setDeletingId(null)}>Cancel</button>
-            <button className="px-4 py-2 rounded-full bg-red-600 text-white hover:brightness-105 cursor-pointer" onClick={confirmDelete}>Delete</button>
-          </div>
-        </div>
-      </div>
-    )}
-  </>
   )
 }
diff --git a/src/app/globals.css b/src/app/globals.css
index 4dd99d2..a2dc41e 100644
--- a/src/app/globals.css
+++ b/src/app/globals.css
@@ -1,41 +1,26 @@
 @import "tailwindcss";
 
-/* Simple light theme */
 :root {
-  --brand: #2e235f; 
   --background: #ffffff;
-  --foreground: #0f172a; /* slate-900 */
+  --foreground: #171717;
 }
 
+@theme inline {
+  --color-background: var(--background);
+  --color-foreground: var(--foreground);
+  --font-sans: var(--font-geist-sans);
+  --font-mono: var(--font-geist-mono);
+}
 
-/* Light mode fallback */
-@media (prefers-color-scheme: light) {
+@media (prefers-color-scheme: dark) {
   :root {
-    --foreground: #0f172a;
+    --background: #0a0a0a;
+    --foreground: #ededed;
   }
 }
 
-/* Remove app-wide gradient */
-.app-gradient { background: var(--background); color: var(--foreground); }
-
-/* Neutral cards */
-.glass-panel { background: #ffffff; border: 1px solid #e5e7eb; }
-.card-glass { background: #ffffff; border: 1px solid #e5e7eb; }
-
-/* Buttons */
-.primary-btn { background: var(--brand); color: #fff; border-radius: 9999px; transition: filter 150ms ease; cursor: pointer; }
-.primary-btn:hover { filter: brightness(1.05); }
-.primary-btn:disabled { opacity: 0.6; cursor: not-allowed; }
-.secondary-btn { background: transparent; border: 1px solid #e5e7eb; color: #0f172a; border-radius: 9999px; cursor: pointer; }
-.secondary-btn:hover { background: #f8fafc; }
-
-/* Ensure all buttons show pointer by default */
-button { cursor: pointer; }
-button:disabled { cursor: not-allowed; }
-
-/* Subtle scrollbars */
-*::-webkit-scrollbar { width: 10px; height: 10px; }
-*::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.35); border-radius: 9999px; }
-*::-webkit-scrollbar-thumb:hover { background: rgba(148,163,184,0.5); }
-
-body { background: var(--background); color: var(--foreground); font-family: var(--font-poppins), Arial, Helvetica, sans-serif; }
+body {
+  background: var(--background);
+  color: var(--foreground);
+  font-family: Arial, Helvetica, sans-serif;
+}
diff --git a/src/app/layout.tsx b/src/app/layout.tsx
index f9fd118..b1abcbd 100644
--- a/src/app/layout.tsx
+++ b/src/app/layout.tsx
@@ -1,12 +1,11 @@
 import type { Metadata } from "next";
-import { Poppins, Geist_Mono } from "next/font/google";
+import { Geist, Geist_Mono } from "next/font/google";
 import "./globals.css";
 import { SessionProvider } from './providers'
 
-const poppins = Poppins({
-  variable: "--font-poppins",
+const geistSans = Geist({
+  variable: "--font-geist-sans",
   subsets: ["latin"],
-  weight: ["300", "400", "500", "600", "700", "800"],
 });
 
 const geistMono = Geist_Mono({
@@ -27,7 +26,7 @@ export default function RootLayout({
   return (
     <html lang="en">
       <body
-        className={`${poppins.variable} ${geistMono.variable} antialiased`}
+        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
       >
         <SessionProvider>
           {children}
diff --git a/src/app/page.tsx b/src/app/page.tsx
index 6f54cc4..f8b387d 100644
--- a/src/app/page.tsx
+++ b/src/app/page.tsx
@@ -1,5 +1,82 @@
-import { redirect } from 'next/navigation'
+'use client'
+
+import { useSession } from 'next-auth/react'
+import { useRouter } from 'next/navigation'
+import { useEffect } from 'react'
+import Link from 'next/link'
 
 export default function Home() {
-  redirect('/auth/signin')
+  const { data: session, status } = useSession()
+  const router = useRouter()
+
+  useEffect(() => {
+    if (status === 'authenticated') {
+      router.push('/dashboard')
+    }
+  }, [status, router])
+
+  if (status === 'loading') {
+    return (
+      <div className="min-h-screen flex items-center justify-center">
+        <div className="text-lg">Loading...</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
+      <div className="container mx-auto px-4 py-16">
+        <div className="text-center">
+          <h1 className="text-6xl font-bold text-gray-900 mb-6">
+            AI <span className="text-indigo-600">Tutor</span>
+          </h1>
+          <p className="text-xl text-gray-600 mb-12 max-w-3xl mx-auto">
+            Transform your PDF documents into interactive learning experiences. 
+            Chat with AI, get instant explanations, and visualize content with smart annotations.
+          </p>
+          
+          <div className="flex gap-4 justify-center">
+            <Link
+              href="/auth/signup"
+              className="bg-indigo-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors"
+            >
+              Get Started
+            </Link>
+            <Link
+              href="/auth/signin"
+              className="border border-indigo-600 text-indigo-600 px-8 py-3 rounded-lg font-semibold hover:bg-indigo-50 transition-colors"
+            >
+              Sign In
+            </Link>
+          </div>
+        </div>
+
+        <div className="mt-20 grid md:grid-cols-3 gap-8">
+          <div className="bg-white p-6 rounded-lg shadow-lg">
+            <div className="text-indigo-600 text-2xl mb-4">📚</div>
+            <h3 className="text-xl font-semibold mb-2">Upload PDFs</h3>
+            <p className="text-gray-600">
+              Simply upload your PDF documents and start learning immediately.
+            </p>
+          </div>
+          
+          <div className="bg-white p-6 rounded-lg shadow-lg">
+            <div className="text-indigo-600 text-2xl mb-4">💬</div>
+            <h3 className="text-xl font-semibold mb-2">Interactive Chat</h3>
+            <p className="text-gray-600">
+              Ask questions about your documents and get instant, contextual answers.
+            </p>
+          </div>
+          
+          <div className="bg-white p-6 rounded-lg shadow-lg">
+            <div className="text-indigo-600 text-2xl mb-4">🎯</div>
+            <h3 className="text-xl font-semibold mb-2">Smart Annotations</h3>
+            <p className="text-gray-600">
+              AI highlights and annotates relevant sections as you learn.
+            </p>
+          </div>
+        </div>
+      </div>
+    </div>
+  )
 }
diff --git a/src/app/tutor/[id]/page.tsx b/src/app/tutor/[id]/page.tsx
index e100db8..a1fd685 100644
--- a/src/app/tutor/[id]/page.tsx
+++ b/src/app/tutor/[id]/page.tsx
@@ -4,7 +4,7 @@ import { useSession } from 'next-auth/react'
 import { useRouter } from 'next/navigation'
 import { useEffect, useState } from 'react'
 import { useParams } from 'next/navigation'
-// import Link from 'next/link'
+import Link from 'next/link'
 import dynamic from 'next/dynamic'
 
 const PDFViewer = dynamic(() => import("@/components/pdf/PDFViewer"), {
@@ -16,7 +16,6 @@ const PDFViewer = dynamic(() => import("@/components/pdf/PDFViewer"), {
 import ChatInterface from '@/components/ChatInterface'
 import { TranscriptProvider } from '@/contexts/TranscriptContext'
 import { EventProvider } from '@/contexts/EventContext'
-import Link from 'next/link'
 
 interface Document {
   id: string
@@ -60,13 +59,6 @@ export default function TutorPage() {
     }
   }, [session, documentId])
 
-  // Expose current document id globally for session-level features
-  useEffect(() => {
-    if (typeof window !== 'undefined' && documentId) {
-      ;(window as any).__currentDocumentId = documentId
-    }
-  }, [documentId])
-
   // Listen for agent tool events
   useEffect(() => {
     const handlePageNavigation = (event: CustomEvent) => {
@@ -101,10 +93,14 @@ export default function TutorPage() {
 
     console.log('🎯 UI: Setting up event listeners')
     window.addEventListener('tutor-page-navigation', handlePageNavigation as EventListener)
+    window.addEventListener('tutor-annotation-created', handleAnnotationCreated as EventListener)
+    window.addEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener)
     console.log('🎯 UI: Event listeners attached')
 
     return () => {
       window.removeEventListener('tutor-page-navigation', handlePageNavigation as EventListener)
+      window.removeEventListener('tutor-annotation-created', handleAnnotationCreated as EventListener)
+      window.removeEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener)
     }
   }, [])
 
@@ -117,21 +113,50 @@ export default function TutorPage() {
         console.log("📄 Document data received:", data);
         setDoc(data)
         
-        // Fetch PDF content for the agent (title is already extracted on upload)
+        // Extract PDF content for the agent
         try {
           const pdfRes = await fetch(`/api/documents/${documentId}/content`)
           if (pdfRes.ok) {
             const { content } = await pdfRes.json()
             console.log("📄 PDF content extracted, length:", content?.length || 0);
+            
+            // Extract the actual title from PDF content
+            let extractedTitle = data.title; // fallback to database title
+            if (content && content.length > 0) {
+              // Look for title patterns in the first few lines of content
+              const lines = content.split('\n').slice(0, 20); // Check first 20 lines
+              for (const line of lines) {
+                const trimmedLine = line.trim();
+                // Look for lines that could be titles (not too long, starts with capital, not empty)
+                if (trimmedLine.length > 3 && 
+                    trimmedLine.length < 200 && 
+                    /^[A-Z]/.test(trimmedLine) && 
+                    !trimmedLine.includes('Abstract') &&
+                    !trimmedLine.includes('Introduction') &&
+                    !trimmedLine.includes('Table of Contents') &&
+                    !trimmedLine.includes('References') &&
+                    !trimmedLine.includes('Bibliography')) {
+                  extractedTitle = trimmedLine;
+                  console.log("📄 Extracted title from PDF content:", extractedTitle);
+                  break;
+                }
+              }
+            }
+            
+            // Update the document title with the extracted title
+            if (data) {
+              setDoc({ ...data, title: extractedTitle });
+            }
             setPdfContent(content)
           } else {
-            const fallbackContent = `Document: ${data.title}\nThis is a PDF document that the student is viewing.`;
+            // Fallback to basic info
+            const fallbackContent = `Document: ${data.title}\nFilename: ${data.filename}\nThis is a PDF document that the student is viewing.`;
             console.log("📄 Using fallback content:", fallbackContent);
             setPdfContent(fallbackContent)
           }
         } catch (error) {
           console.error('Error extracting PDF content:', error)
-          const fallbackContent = `Document: ${data.title}\nThis is a PDF document that the student is viewing.`;
+          const fallbackContent = `Document: ${data.title}\nFilename: ${data.filename}\nThis is a PDF document that the student is viewing.`;
           console.log("📄 Using fallback content due to error:", fallbackContent);
           setPdfContent(fallbackContent)
         }
@@ -233,6 +258,18 @@ export default function TutorPage() {
     console.log('Voice input:', isRecording)
   }
 
+  const navigateToAnnotation = (index: number) => {
+    // This function is no longer needed as annotations are removed
+  }
+
+  const nextAnnotation = () => {
+    // This function is no longer needed as annotations are removed
+  }
+
+  const prevAnnotation = () => {
+    // This function is no longer needed as annotations are removed
+  }
+
   if (status === 'loading' || loading) {
     return (
       <div className="min-h-screen flex items-center justify-center">
@@ -240,6 +277,7 @@ export default function TutorPage() {
       </div>
     )
   }
+
   if (status === 'unauthenticated') {
     return null
   }
@@ -273,13 +311,28 @@ export default function TutorPage() {
       {/* Header */}
       <header className="flex items-center justify-between p-4 bg-white border-b shadow-sm">
         <div className="flex items-center gap-4">
+          <Link
+            href="/dashboard"
+            className="text-indigo-600 hover:text-indigo-700 transition-colors"
+          >
+            ← Dashboard
+          </Link>
           <div>
             <h1 className="text-xl font-semibold text-gray-900">{doc.title}</h1>
-            <p className="text-sm text-gray-600">{doc.title}</p>
+            <p className="text-sm text-gray-600">{doc.filename}</p>
           </div>
         </div>
-        <div className="flex items-center gap-3 relative">
-          <UserMenu name={session?.user?.name || session?.user?.email || 'Test User'} documentId={documentId} />
+        <div className="flex items-center gap-3">
+          <div className="text-sm text-gray-600 hidden md:block">
+            Welcome, {session?.user?.name || session?.user?.email}
+          </div>
+          <button
+            onClick={() => router.back()}
+            className="px-4 py-2 bg-gray-500 text-white rounded-lg font-medium hover:bg-gray-600"
+            title="Back"
+          >
+            Back
+          </button>
         </div>
       </header>
 
@@ -322,27 +375,3 @@ export default function TutorPage() {
     </div>
   )
 }
-
-function UserMenu({ name, documentId }: { name: string, documentId: string }) {
-  const initials = (name || 'TU').split(' ').map(s => s[0]).slice(0,2).join('').toUpperCase()
-  const [open, setOpen] = useState(false)
-  return (
-    <div className="relative">
-      <button className="secondary-btn px-3 py-2 rounded-full flex items-center gap-2 cursor-pointer" onClick={() => setOpen(!open)} aria-haspopup="menu" aria-expanded={open}>
-        <span className="inline-flex h-6 w-6 items-center justify-center rounded-full bg-[var(--brand)] text-white text-xs">{initials}</span>
-        <span className="hidden sm:inline text-slate-700">{name}</span>
-        <span className="text-slate-500">▾</span>
-      </button>
-      {open && (
-        <div className="absolute right-0 mt-2 w-44 rounded-xl border bg-white shadow-md z-50">
-          <Link href="/dashboard" className="block px-3 py-2 hover:bg-slate-50 cursor-pointer">Dashboard</Link>
-          <button className="w-full text-left px-3 py-2 hover:bg-slate-50 cursor-pointer" onClick={() => {
-            window.dispatchEvent(new CustomEvent('toggle-chat-history', { detail: true }))
-            setOpen(false)
-          }}>Chat History</button>
-          <Link href="/upload" className="block px-3 py-2 hover:bg-slate-50 cursor-pointer">Upload</Link>
-        </div>
-      )}
-    </div>
-  )
-}
diff --git a/src/components/ChatInterface.tsx b/src/components/ChatInterface.tsx
index 76ce4d5..aaf9f49 100644
--- a/src/components/ChatInterface.tsx
+++ b/src/components/ChatInterface.tsx
@@ -1,7 +1,7 @@
 'use client'
 
 import React, { useRef, useState, useEffect, useMemo } from 'react'
-import { Send, Volume2, VolumeX, Mic, Clock } from 'lucide-react'
+import { Send, Volume2, VolumeX, Mic } from 'lucide-react'
 import { useTranscript } from '@/contexts/TranscriptContext'
 import { useRealtimeSession } from '@/hooks/useRealtimeSession'
 import { useHandleSessionHistory } from '@/hooks/useHandleSessionHistory'
@@ -30,6 +30,7 @@ interface ChatInterfaceProps {
   documentId: string
   onNewSession?: () => void
 }
+
 export default function ChatInterface({ 
   messages, 
   onSendMessage, 
@@ -55,10 +56,7 @@ export default function ChatInterface({
   const audioElementRef = useRef<HTMLAudioElement | null>(null)
   const containerRef = useRef<HTMLDivElement>(null)
   const [fixedInputStyle, setFixedInputStyle] = useState<React.CSSProperties>({})
-  const lastSpokenHighlightRef = useRef<{ text: string; at: number } | null>(null)
-  // Semantic similarity debounce state
-  const simBufferRef = useRef<string>('')
-  const simTimerRef = useRef<number | null>(null)
+
   // Keep fixed input aligned to chat pane width/position
   useEffect(() => {
     const update = () => {
@@ -76,13 +74,17 @@ export default function ChatInterface({
       window.removeEventListener('scroll', update, true)
     }
   }, [])
+
   // Use transcript context for real-time message handling
   const { transcriptItems, clearTranscript } = useTranscript()
+  
   // Use session history handler to process realtime events
   const sessionHistoryHandler = useHandleSessionHistory()
+
   // Helper to get all messages including transcript items
   const getAllMessages = () => {
     const allMessages = [...messages];
+    
     // Add transcript items that aren't already in messages
     transcriptItems.forEach(item => {
       if (item.type === 'MESSAGE' && !item.isHidden && (item.role === 'user' || item.role === 'assistant')) {
@@ -100,6 +102,7 @@ export default function ChatInterface({
     
     return allMessages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
   };
+
   // Fetch chat history
   const fetchChatHistory = async () => {
     try {
@@ -115,6 +118,7 @@ export default function ChatInterface({
       setLoadingHistory(false);
     }
   };
+
   // Load a specific chat
   const loadChat = async (chatId: string) => {
     try {
@@ -128,6 +132,7 @@ export default function ChatInterface({
       console.error('Error loading chat:', error);
     }
   };
+
   // Delete a specific chat
   const deleteChat = async (chatId: string, event: React.MouseEvent) => {
     event.stopPropagation(); // Prevent loading the chat when clicking delete
@@ -143,6 +148,7 @@ export default function ChatInterface({
       console.error('Error deleting chat:', error);
     }
   };
+
   // Create audio element
   const sdkAudioElement = useMemo(() => {
     if (typeof window === 'undefined') return undefined
@@ -152,6 +158,7 @@ export default function ChatInterface({
     el.volume = 1.0
     el.style.display = 'none'
     document.body.appendChild(el)
+    
     // Add event listeners to debug audio
     el.addEventListener('loadedmetadata', () => {
       console.log("🎵 Audio metadata loaded");
@@ -183,34 +190,29 @@ export default function ChatInterface({
       setSessionStatus(status as SessionStatus)
     },
   })
+
   // No auto-scroll - let users control their own scroll position
   // Users can scroll up to view history, new messages appear at bottom
+
   // Monitor scroll position to show/hide scroll to bottom button
   useEffect(() => {
     const messagesContainer = document.querySelector('.chat-messages') as HTMLElement;
     if (!messagesContainer) return;
+
     const handleScroll = () => {
       const isNearBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;
       setShowScrollToBottom(!isNearBottom);
     };
+
     messagesContainer.addEventListener('scroll', handleScroll);
     return () => messagesContainer.removeEventListener('scroll', handleScroll);
   }, []);
-// Allow external toggle of chat history via a global event
-  useEffect(() => {
-    const handler = (e: Event) => {
-      const val = (e as CustomEvent).detail
-      if (typeof val === 'boolean') setShowChatHistory(val)
-      else setShowChatHistory(true)
-    }
-    window.addEventListener('toggle-chat-history', handler as EventListener)
-    return () => window.removeEventListener('toggle-chat-history', handler as EventListener)
-  }, [])
 
   // Function to scroll to bottom (manual control)
   const scrollToBottom = () => {
     messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
   };
+
   // Listen to agent speech transcription for real-time annotation
   useEffect(() => {
     const handleSpeechTranscription = (event: any) => {
@@ -218,40 +220,146 @@ export default function ChatInterface({
       if (!transcript || typeof transcript !== 'string') return;
       
       console.log('🎤 Agent speech delta:', transcript);
-      const isDelta = Boolean((event as any)?.delta);
-      // Annotations disabled
-      return;
-      // Highlighting disabled
+      
+      // Analyze the speech for citation patterns
+      const citationMatches = transcript.match(/\[(\d+)\]|([A-Z][a-z]+\s+et\s+al\.?,?\s+\d{4})|([A-Z][a-z]+,?\s+\d{4})/g);
+      if (citationMatches) {
+        citationMatches.forEach(citation => {
+          console.log('📚 Detected citation in speech:', citation);
+          // Trigger citation research
+          window.dispatchEvent(new CustomEvent('tutor-citation-research', {
+            detail: { 
+              citation: citation.trim(),
+              context: transcript,
+              requestId: `speech-citation-${Date.now()}`
+            }
+          }));
+        });
+      }
+      
+      // Analyze speech for table/figure references
+      const tableMatches = transcript.match(/Table\s+\d+/gi);
+      if (tableMatches) {
+        tableMatches.forEach(table => {
+          console.log('📊 Detected table reference in speech:', table);
+          setTimeout(() => {
+            window.dispatchEvent(new CustomEvent('tutor-circle-table', {
+              detail: { label: table.trim() }
+            }));
+          }, 200); // Small delay to sync with speech
+        });
+      }
+      
+      const figureMatches = transcript.match(/Figure\s+\d+/gi);
+      if (figureMatches) {
+        figureMatches.forEach(figure => {
+          console.log('📈 Detected figure reference in speech:', figure);
+          setTimeout(() => {
+            window.dispatchEvent(new CustomEvent('tutor-circle-figure', {
+              detail: { label: figure.trim() }
+            }));
+          }, 200);
+        });
+      }
+      
+      // Analyze speech for direct quotes (text in quotes)
+      const quoteMatches = transcript.match(/"([^"]+)"/g);
+      if (quoteMatches) {
+        quoteMatches.forEach(quote => {
+          const cleanQuote = quote.replace(/"/g, '').trim();
+          if (cleanQuote.length > 10) {
+            console.log('💬 Detected quote in speech:', cleanQuote);
+            setTimeout(() => {
+              window.dispatchEvent(new CustomEvent('tutor-highlight-quote', {
+                detail: { text: cleanQuote }
+              }));
+            }, 300);
+          }
+        });
+      }
     };
+
     // Listen to speech transcription events
     window.addEventListener('response.audio_transcript.delta', handleSpeechTranscription);
     window.addEventListener('response.audio_transcript.done', handleSpeechTranscription);
+    
     return () => {
       window.removeEventListener('response.audio_transcript.delta', handleSpeechTranscription);
       window.removeEventListener('response.audio_transcript.done', handleSpeechTranscription);
     };
   }, []);
 
+  // Handle citation research requests
+  useEffect(() => {
+    const handleCitationResearch = (event: Event) => {
+      const { citation, context, requestId } = (event as CustomEvent).detail || {};
+      console.log('📚 Citation research request received:', { citation, context, requestId });
+      
+      if (!citation) {
+        console.warn('📚 No citation provided for research');
+        return;
+      }
+
+      try {
+        // Add a message to show research is starting
+        const researchMessage: Message = {
+          id: `citation-research-${Date.now()}`,
+          role: 'assistant',
+          content: `🔍 Researching citation: ${citation}...`,
+          timestamp: new Date()
+        };
+        setMessages(prev => [...prev, researchMessage]);
+
+        // Simulate citation research (in a real implementation, this would use the citation agent)
+        setTimeout(() => {
+          const resultMessage: Message = {
+            id: `citation-result-${Date.now()}`,
+            role: 'assistant',
+            content: `📚 **Citation Research Results for: ${citation}**\n\nThis citation appears to reference an academic paper. Based on the context: "${context || 'No context provided'}"\n\n*Note: This is a placeholder implementation. In a full system, this would search academic databases to provide detailed information about the referenced paper, including authors, title, abstract, and relevance to the current document.*\n\n**Next steps:** You could ask me to explain how this citation relates to the current document, or ask about other citations you're interested in.`,
+            timestamp: new Date()
+          };
+          setMessages(prev => [...prev, resultMessage]);
+        }, 2000);
+
+      } catch (error) {
+        console.error('📚 Error handling citation research:', error);
+        const errorMessage: Message = {
+          id: `citation-error-${Date.now()}`,
+          role: 'assistant',
+          content: `❌ Sorry, I encountered an error while researching the citation: ${citation}`,
+          timestamp: new Date()
+        };
+        setMessages(prev => [...prev, errorMessage]);
+      }
+    };
+
+    window.addEventListener('tutor-citation-research', handleCitationResearch);
+    return () => {
+      window.removeEventListener('tutor-citation-research', handleCitationResearch);
+    };
+  }, [setMessages]);
+
   const fetchEphemeralKey = async (): Promise<string | null> => {
     try {
+      console.log("🔑 Attempting to fetch ephemeral key...");
       const response = await fetch('/api/session', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
       });
 
-      console.log("Response status:", response.status, response.statusText);
+      console.log("🔑 Response status:", response.status, response.statusText);
 
       if (!response.ok) {
         const errorData = await response.json().catch(() => ({}));
-        console.error(` Failed to get ephemeral key: ${response.status} ${response.statusText}`, errorData);
+        console.error(`❌ Failed to get ephemeral key: ${response.status} ${response.statusText}`, errorData);
         
         // More specific error messages
         if (response.status === 500) {
-          console.error("Server error - check OpenAI API key configuration");
+          console.error("❌ Server error - check OpenAI API key configuration");
         } else if (response.status === 401) {
-          console.error("Authentication error - session may be expired");
+          console.error("❌ Authentication error - session may be expired");
         } else if (response.status === 429) {
-          console.error("Rate limited - too many requests to OpenAI API");
+          console.error("❌ Rate limited - too many requests to OpenAI API");
         }
         
         throw new Error(`HTTP error! status: ${response.status}`);
@@ -263,10 +371,10 @@ export default function ChatInterface({
         throw new Error('No ephemeral key received from server');
       }
       
-      console.log('Ephemeral key fetched successfully');
+      console.log('✅ Ephemeral key fetched successfully');
       return data.ephemeralKey;
     } catch (error) {
-      console.error('Error fetching ephemeral key:', error);
+      console.error('❌ Error fetching ephemeral key:', error);
       return null;
     }
   };
@@ -278,13 +386,16 @@ export default function ChatInterface({
 
     try {
       // Clear transcript before connecting to ensure clean state
+      console.log("🧹 Clearing transcript before connecting...")
       clearTranscript()
+      console.log("🔑 Fetching ephemeral key...")
       const ephemeralKey = await fetchEphemeralKey()
       if (!ephemeralKey) {
-        console.error("Failed to get ephemeral key, cannot connect to voice")
+        console.error("❌ Failed to get ephemeral key, cannot connect to voice")
         setSessionStatus('DISCONNECTED')
         return
       }
+      console.log("🔑 Ephemeral key received successfully")
 
       if (!audioElementRef.current) {
         console.error("Audio element not available")
@@ -294,10 +405,21 @@ export default function ChatInterface({
       // Ensure audio element is ready
       audioElementRef.current.muted = false
       audioElementRef.current.volume = 1.0
+      console.log("🎵 Audio element ready for connection")
+
+      console.log("🤖 Creating tutor agent with:", {
+        pdfTitle: pdfTitle,
+        pdfContentLength: pdfContent?.length || 0,
+        pdfTitleType: typeof pdfTitle,
+        pdfTitleValue: pdfTitle
+      });
 
       // Ensure we have a valid title
       const safeTitle = pdfTitle && pdfTitle.trim() ? pdfTitle.trim() : 'PDF Document';
+      console.log("🤖 Using safe title:", safeTitle);
+
       const tutorAgent = createTutorAgent(safeTitle, pdfContent)
+      
       await connect({
         getEphemeralKey: () => Promise.resolve(ephemeralKey),
         initialAgents: [tutorAgent],
@@ -309,30 +431,36 @@ export default function ChatInterface({
         outputGuardrails: []
       })
       
+      console.log("✅ Voice connection successful")
+      
+      // Enable transcription immediately and trigger greeting
       try {
+        console.log("🤖 Triggering agent introduction...");
         updateSession(true);
         
         // Also send a direct response.create event as backup
         setTimeout(() => {
           try {
+            console.log("🤖 Backup: Sending response.create event...");
             sendEvent({ type: "response.create" });
           } catch (err) {
-            console.error("Failed to send backup response.create:", err);
+            console.error("❌ Failed to send backup response.create:", err);
           }
         }, 1000);
         
       } catch (error) {
-        console.error("Failed to start transcription:", error);
+        console.error("❌ Failed to start transcription:", error);
       }
       
     } catch (error) {
-      console.error("Voice connection failed:", error)
+      console.error("❌ Voice connection failed:", error)
     }
   }
 
   const disconnectFromRealtime = async () => {
     try {
       await disconnect()
+      console.log("✅ Voice disconnected")
     } catch (error) {
       console.error('Error disconnecting voice:', error)
     }
@@ -356,6 +484,7 @@ export default function ChatInterface({
     });
 
     if (shouldTriggerResponse) {
+      console.log("🔧 Triggering response.create");
       sendEvent({ type: "response.create" });
     }
   };
@@ -421,57 +550,6 @@ export default function ChatInterface({
   // Detect references like "Table 1" (optionally with a page mention) in assistant outputs
   const lastProcessedMsgIdRef = useRef<string | null>(null)
   const lastProcessedTranscriptIdRef = useRef<string | null>(null)
-  // Debounce timer for similarity-driven highlights
-  const simDebounceTimerRef = useRef<number | null>(null)
-
-  const highlightWithSemanticSnippets = async (text: string) => {
-    try {
-      if (!documentId || !text || text.trim().length < 4) return
-      console.log('[Semantic] Requesting snippets for', { documentId, textLen: text.length })
-      const res = await fetch(`/api/documents/${documentId}/similarity`, {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ text, topK: 5 })
-      })
-      if (!res.ok) return
-      const data = await res.json()
-      const snippets: string[] = Array.isArray(data?.snippets) ? data.snippets.map((s: any) => String(s?.snippet || '').trim()).filter(Boolean) : []
-      console.log('[Semantic] Received snippets', { count: snippets.length, snippets })
-      try {
-        if (typeof window !== 'undefined') {
-          ;(window as any).__lastSemanticSnippets = snippets
-          window.dispatchEvent(new CustomEvent('semantic-snippets', { detail: { snippets } }))
-        }
-      } catch {}
-      if (snippets.length === 0) return
-      const tryHighlight = async (attempts: number) => {
-        try {
-          if (typeof window !== 'undefined') {
-            const api = (window as any).pdfHighlighter
-            const ready = (window as any).__pdfReady === true
-            if (!ready) {
-              console.log('[Semantic] PDF not ready, waiting for pdf-ready event')
-              const once = () => {
-                window.removeEventListener('pdf-ready', once as EventListener)
-                setTimeout(() => { tryHighlight(attempts - 1) }, 100)
-              }
-              window.addEventListener('pdf-ready', once as EventListener, { once: true })
-              return
-            }
-            if (api?.highlightSnippets) {
-              const count = await api.highlightSnippets(snippets)
-              console.log('[Semantic] highlightSnippets applied', { count })
-              return
-            }
-          }
-        } catch {}
-        if (attempts > 0) setTimeout(() => tryHighlight(attempts - 1), 250)
-      }
-      tryHighlight(8)
-    } catch (err) {
-      console.error('Semantic highlight error:', err)
-    }
-  }
 
   const wordsToNumber = (word: string): number | null => {
     const map: Record<string, number> = {
@@ -500,6 +578,20 @@ export default function ChatInterface({
     return undefined
   }
 
+  const maybeCircleTable = (text: string) => {
+    if (!text) return
+    const tableMatch = text.match(/table\s*(\d+)/i)
+    if (!tableMatch) return
+    const tableNum = tableMatch[1]
+    const pageNum = extractPageNumber(text)
+    try {
+      console.log('📤 Dispatching pdf-circle-text', { text: `Table ${tableNum}`, page: pageNum })
+      window.dispatchEvent(new CustomEvent('pdf-circle-text', { detail: { text: `Table ${tableNum}`, page: pageNum } }))
+    } catch (e) {
+      console.warn('Failed to dispatch pdf-circle-text event', e)
+    }
+  }
+
   // Watch standard assistant messages
   useEffect(() => {
     if (!messages || messages.length === 0) return
@@ -507,8 +599,7 @@ export default function ChatInterface({
     if (!last || last.role !== 'assistant') return
     if (lastProcessedMsgIdRef.current === last.id) return
     lastProcessedMsgIdRef.current = last.id
-    // Trigger semantic similarity highlights for assistant responses
-    highlightWithSemanticSnippets(last.content)
+    maybeCircleTable(last.content)
   }, [messages])
 
   // Watch real-time transcript assistant items
@@ -519,20 +610,23 @@ export default function ChatInterface({
     const last = items[items.length - 1]
     if (lastProcessedTranscriptIdRef.current === (last as any).itemId) return
     lastProcessedTranscriptIdRef.current = (last as any).itemId
-    // Debounced semantic highlights for realtime transcript (assistant)
-    const text = String((last as any).title || '').trim()
-    if (!text) return
-    if (simDebounceTimerRef.current) window.clearTimeout(simDebounceTimerRef.current)
-    simDebounceTimerRef.current = window.setTimeout(() => {
-      highlightWithSemanticSnippets(text)
-    }, 800)
+    maybeCircleTable((last as any).title || '')
   }, [transcriptItems])
 
   return (
     <div ref={containerRef} className="chat-interface-container h-full bg-white flex flex-col overflow-hidden relative">
+      {/* Header - GLUED TO TOP */}
+      <div className="chat-header bg-white border-b p-4 flex-shrink-0">
+        <div className="flex items-center justify-between">
+          <div>
+            <h2 className="text-xl font-semibold text-gray-800">AI Tutor Chat</h2>
+            <p className="text-sm text-gray-600">Ask questions about your PDF document</p>
+          </div>
+        </div>
+      </div>
 
       {/* Connect Button */}
-      <div className="chat-connect bg-slate-50 border-b p-4 flex-shrink-0">
+      <div className="chat-connect bg-blue-50 border-b p-4 flex-shrink-0">
         <div className="flex items-center justify-center gap-4">
           <button
             onClick={async () => {
@@ -593,12 +687,12 @@ export default function ChatInterface({
               }
             }}
             disabled={sessionStatus === 'CONNECTING'}
-            className={`px-6 py-3 rounded-full font-medium ${
+            className={`px-6 py-3 rounded-lg font-medium ${
               sessionStatus === 'CONNECTED'
-                ? 'bg-red-600 text-white hover:brightness-105'
+                ? 'bg-red-500 text-white hover:bg-red-600'
                 : sessionStatus === 'CONNECTING'
                 ? 'bg-yellow-500 text-white cursor-not-allowed'
-                : 'bg-[var(--brand)] text-white hover:brightness-105'
+                : 'bg-blue-600 text-white hover:bg-blue-700'
             }`}
             title={sessionStatus === 'CONNECTED' ? 'Disconnect from AI tutor' : 'Start new chat and connect to AI tutor'}
           >
@@ -613,15 +707,14 @@ export default function ChatInterface({
                 fetchChatHistory();
               }
             }}
-            className={`h-12 w-12 rounded-full flex items-center justify-center ${
+            className={`px-4 py-3 rounded-lg font-medium ${
               showChatHistory 
-                ? 'bg-[var(--brand)] text-white' 
-                : 'bg-gray-800 text-white hover:bg-gray-700'
+                ? 'bg-blue-600 text-white' 
+                : 'bg-gray-500 text-white hover:bg-gray-600'
             }`}
-            title="Chat history"
-            aria-label="Chat history"
+            title="View chat history"
           >
-            <Clock className="w-5 h-5" />
+            {showChatHistory ? 'Hide History' : 'Chat History'}
           </button>
         </div>
         
@@ -649,7 +742,7 @@ export default function ChatInterface({
                   <div
                     key={chat.id}
                     onClick={() => loadChat(chat.id)}
-                    className="p-3 mb-2 bg-white rounded-lg border cursor-pointer hover:bg-slate-50 hover:border-[var(--brand)] transition-colors relative group"
+                    className="p-3 mb-2 bg-white rounded-lg border cursor-pointer hover:bg-blue-50 hover:border-blue-300 transition-colors relative group"
                   >
                     <div className="text-sm font-medium text-gray-900">
                       {new Date(chat.timestamp).toLocaleDateString()}
@@ -689,9 +782,9 @@ export default function ChatInterface({
                     className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
                   >
                     <div
-                      className={`max-w-[80%] rounded-2xl px-4 py-2 ${
+                      className={`max-w-[80%] rounded-lg px-4 py-2 ${
                         message.role === 'user'
-                          ? 'bg-[var(--brand)] text-white'
+                          ? 'bg-indigo-600 text-white'
                           : 'bg-gray-100 text-gray-900'
                       }`}
                     >
@@ -709,9 +802,9 @@ export default function ChatInterface({
                     const isUser = item.role === "user"
                     return (
                       <div key={item.itemId} className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
-                        <div className={`max-w-[80%] rounded-2xl px-4 py-2 ${
+                        <div className={`max-w-[80%] rounded-lg px-4 py-2 ${
                           isUser 
-                            ? "bg-[var(--brand)] text-white" 
+                            ? "bg-indigo-600 text-white" 
                             : "bg-green-100 text-gray-900"
                         }`}>
                           <div className="text-sm">{item.title}</div>
@@ -739,7 +832,7 @@ export default function ChatInterface({
             <div className="absolute bottom-36 right-4 z-20">
               <button
                 onClick={scrollToBottom}
-                className="bg-[var(--brand)] text-white rounded-full p-3 shadow-lg hover:brightness-105 transition-colors"
+                className="bg-indigo-600 text-white rounded-full p-3 shadow-lg hover:bg-indigo-700 transition-colors"
                 title="Scroll to latest messages"
               >
                 <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
@@ -752,29 +845,27 @@ export default function ChatInterface({
       </div>
 
       {/* Input Form - FIXED, CONSTRAINED TO CHAT PANE */}
-      {sessionStatus === 'CONNECTED' && (
-        <div className="chat-input fixed bottom-0 bg-white border-t p-4 z-30" style={fixedInputStyle}>
-          <form onSubmit={handleSubmit} className="flex items-end gap-2">
-            <textarea
-              ref={inputRef}
-              value={inputMessage}
-              onChange={(e) => setInputMessage(e.target.value)}
-              onKeyDown={handleKeyDown}
-              placeholder="Ask a question about your PDF..."
-              className="flex-1 resize-none rounded-xl border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-[var(--brand)]"
-              rows={1}
-              disabled={isLoading}
-            />
-            <button
-              type="submit"
-              disabled={!inputMessage.trim() || isLoading}
-              className="px-4 py-2 bg-[var(--brand)] text-white rounded-full hover:brightness-105 disabled:opacity-50"
-            >
-              Send
-            </button>
-          </form>
-        </div>
-      )}
+      <div className="chat-input fixed bottom-0 bg-gray-50 border-t p-4 z-30" style={fixedInputStyle}>
+        <form onSubmit={handleSubmit} className="flex items-end gap-2">
+          <textarea
+            ref={inputRef}
+            value={inputMessage}
+            onChange={(e) => setInputMessage(e.target.value)}
+            onKeyDown={handleKeyDown}
+            placeholder="Ask a question about your PDF..."
+            className="flex-1 resize-none rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
+            rows={1}
+            disabled={isLoading}
+          />
+          <button
+            type="submit"
+            disabled={!inputMessage.trim() || isLoading}
+            className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:opacity-50"
+          >
+            Send
+          </button>
+        </form>
+      </div>
     </div>
   )
 }
diff --git a/src/components/SignOutButton.tsx b/src/components/SignOutButton.tsx
index 08aaa9f..60c43fe 100644
--- a/src/components/SignOutButton.tsx
+++ b/src/components/SignOutButton.tsx
@@ -1,7 +1,6 @@
 'use client'
 
 import { useSession, signOut } from 'next-auth/react'
-import { Button } from '@/components/ui/Button'
 
 export default function SignOutButton() {
   const { status } = useSession()
@@ -9,16 +8,13 @@ export default function SignOutButton() {
   if (status !== 'authenticated') return null
 
   return (
-    <div className="fixed top-3 right-3 z-50">
-      <Button
-        onClick={() => signOut()}
-        size="sm"
-        className="rounded-full bg-gray-800 text-white hover:bg-gray-700"
-        aria-label="Sign out"
-      >
-        Sign out
-      </Button>
-    </div>
+    <button
+      onClick={() => signOut()}
+      className="fixed top-3 right-3 z-50 rounded-md bg-gray-800 text-white px-3 py-1.5 text-sm hover:bg-gray-700 transition-colors"
+      aria-label="Sign out"
+    >
+      Sign out
+    </button>
   )
 }
 
diff --git a/src/components/pdf/AreaHighlight.tsx b/src/components/pdf/AreaHighlight.tsx
index 574b41f..ffa2db9 100644
--- a/src/components/pdf/AreaHighlight.tsx
+++ b/src/components/pdf/AreaHighlight.tsx
@@ -17,8 +17,8 @@ export const AreaHighlight: React.FC<AreaHighlightProps> = ({
   width,
   height,
   type = 'circle',
-  color = 'rgba(239, 68, 68, 0.06)',
-  borderColor = '#fca5a5'
+  color = 'rgba(239, 68, 68, 0.1)',
+  borderColor = '#ef4444'
 }) => {
   const style: React.CSSProperties = {
     position: 'absolute',
@@ -27,9 +27,9 @@ export const AreaHighlight: React.FC<AreaHighlightProps> = ({
     width: `${width}px`,
     height: `${height}px`,
     background: color,
-    border: `2px solid ${borderColor}`,
+    border: `3px solid ${borderColor}`,
     borderRadius: type === 'circle' ? '50%' : '8px',
-    boxShadow: `0 0 0 1px rgba(252,165,165,0.3)`,
+    boxShadow: `0 0 0 2px ${borderColor}25`,
     pointerEvents: 'none',
     zIndex: 9999,
   };
diff --git a/src/components/pdf/PDFViewer.tsx b/src/components/pdf/PDFViewer.tsx
index c8f8c8d..2890313 100644
--- a/src/components/pdf/PDFViewer.tsx
+++ b/src/components/pdf/PDFViewer.tsx
@@ -1,347 +1,1437 @@
-"use client"
+"use client";
 
-import React, { useEffect, useRef, useState } from "react";
+import React, { useState, useEffect, useRef } from "react";
 import { Viewer, Worker } from '@react-pdf-viewer/core';
 import { defaultLayoutPlugin } from '@react-pdf-viewer/default-layout';
-import { searchPlugin } from '@react-pdf-viewer/search';
-import { highlightPlugin } from '@react-pdf-viewer/highlight';
+import { searchPlugin, SingleKeyword, Match } from '@react-pdf-viewer/search';
 import { pageNavigationPlugin } from '@react-pdf-viewer/page-navigation';
 
 // Import styles
 import '@react-pdf-viewer/core/lib/styles/index.css';
 import '@react-pdf-viewer/default-layout/lib/styles/index.css';
 import '@react-pdf-viewer/search/lib/styles/index.css';
-import '@react-pdf-viewer/highlight/lib/styles/index.css';
 
 interface PDFViewerProps {
-  fileUrl: string;
-  currentPage?: number;
-  onPageChange?: (page: number) => void;
+  fileUrl: string
+  onPageChange?: (page: number) => void
+  currentPage?: number
 }
 
-const PDFViewer: React.FC<PDFViewerProps> = ({ fileUrl, currentPage, onPageChange }) => {
-  const defaultLayout = useRef(defaultLayoutPlugin()).current;
-  const search = useRef(searchPlugin()).current;
-  const highlight = useRef(highlightPlugin({
-    renderHighlights: (props: any) => {
-      try {
-        const areas = hlAreasRef.current[props.pageIndex] || [];
-        return (
-          <>
-            {areas.map((area, idx) => (
-              <div
-                key={idx}
-                style={{
-                  ...(props.getCssProperties ? props.getCssProperties(area) : {}),
-                  background: 'rgba(250, 204, 21, 0.35)',
-                  outline: '2px solid rgba(234,179,8,0.8)',
-                  borderRadius: '4px',
-                  pointerEvents: 'none',
-                }}
-              />
-            ))}
-          </>
-        );
-      } catch {
-        return <></>;
-      }
-    }
-  })).current;
-  const [hlAreas, setHlAreas] = useState<Record<number, Array<{ left: number; top: number; width: number; height: number }>>>({});
-  const hlAreasRef = useRef<Record<number, Array<{ left: number; top: number; width: number; height: number }>>>({});
-  const pageNavigationRef = useRef(pageNavigationPlugin());
-  const pageNavigation = pageNavigationRef.current;
-
-  // Track readiness and pending navigation requests
-  const readyRef = useRef<boolean>(false);
+const PDFViewer: React.FC<PDFViewerProps> = ({
+  fileUrl,
+  onPageChange,
+  currentPage = 1
+}) => {
+  const rootRef = useRef<HTMLDivElement | null>(null);
+  const [isDocLoaded, setIsDocLoaded] = useState(false);
   const pendingNavRef = useRef<number | null>(null);
+  const lastKeywordsRef = useRef<SingleKeyword | SingleKeyword[] | undefined>(undefined);
 
-  // Expose search plugin for debugging
-  useEffect(() => {
-    try { (window as any).__rpvSearch = search; } catch {}
-  }, [search]);
-
-  // Unified jump helper with fallback
-  const jumpToIndex = useRef((idx: number) => {
-    const safeIdx = Math.max(0, Number(idx) || 0);
-    try { pageNavigation.jumpToPage(safeIdx); } catch {}
-    // Fallback: ensure the DOM page layer is brought into view
+  const scrollToPageIndex = (zeroBasedIndex: number, attempts: number = 10) => {
+    if (attempts <= 0) return;
     try {
-      setTimeout(() => {
-        const pageLayer = document.querySelector(`[data-testid="core__page-layer-${safeIdx}"]`) as HTMLElement | null;
-        if (!pageLayer) return;
-        pageLayer.scrollIntoView({ block: 'start', behavior: 'smooth' });
-      }, 50);
-    } catch {}
-  }).current;
-
-  const requestJump = useRef((idx: number) => {
-    if (!readyRef.current) {
-      pendingNavRef.current = Math.max(0, Number(idx) || 0);
-      const once = () => {
-        window.removeEventListener('pdf-ready', once as EventListener);
-        if (pendingNavRef.current !== null) {
-          jumpToIndex(pendingNavRef.current);
-          pendingNavRef.current = null;
+      // react-pdf-viewer sets data-testid="core__page-layer-{pageIndex}" where pageIndex is zero-based
+      const selectorByTestId = `[data-testid="core__page-layer-${zeroBasedIndex}"]`;
+      const el = document.querySelector(selectorByTestId) as HTMLElement | null;
+      const container = document.querySelector('[data-testid="core__inner-pages"]') as HTMLElement | null;
+      
+      // Safety check for DOM elements
+      if (!el || !container) {
+        console.log(`🔍 PDF: DOM elements not ready for page ${zeroBasedIndex}, attempt ${11 - attempts}/10`);
+        setTimeout(() => scrollToPageIndex(zeroBasedIndex, attempts - 1), 150);
+        return;
+      }
+      
+      if (el) {
+        if (container && typeof (container as any).scrollTo === 'function') {
+          try {
+            const contRect = container.getBoundingClientRect();
+            const pageRect = el.getBoundingClientRect();
+            const delta = (pageRect.top - contRect.top) + container.scrollTop;
+            const targetTop = Math.max(0, delta - (container.clientHeight / 2) + (pageRect.height / 2));
+            container.scrollTo({ top: targetTop, behavior: 'smooth' });
+          } catch (scrollError) {
+            console.warn("🔍 PDF: Smooth scroll failed, using fallback:", scrollError);
+            try {
+              const contRect = container.getBoundingClientRect();
+              const pageRect = el.getBoundingClientRect();
+              const delta = (pageRect.top - contRect.top) + container.scrollTop;
+              const targetTop = Math.max(0, delta - (container.clientHeight / 2) + (pageRect.height / 2));
+              container.scrollTop = targetTop;
+            } catch (fallbackError) {
+              console.warn("🔍 PDF: Fallback scroll also failed:", fallbackError);
+            }
+          }
+        } else {
+          try {
+            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
+          } catch (scrollError) {
+            console.warn("🔍 PDF: scrollIntoView failed:", scrollError);
+          }
         }
-      };
-      window.addEventListener('pdf-ready', once as EventListener, { once: true });
-      return;
+        return;
+      }
+      
+      // Fallback to any future attribute we may support
+      const fallback = document.querySelector(`[data-page-number="${zeroBasedIndex + 1}"]`) as HTMLElement | null;
+      if (fallback && container) {
+        try {
+          if (typeof (container as any).scrollTo === 'function') {
+            const contRect = container.getBoundingClientRect();
+            const pageRect = fallback.getBoundingClientRect();
+            const delta = (pageRect.top - contRect.top) + container.scrollTop;
+            const targetTop = Math.max(0, delta - (container.clientHeight / 2) + (pageRect.height / 2));
+            container.scrollTo({ top: targetTop, behavior: 'smooth' });
+          } else {
+            fallback.scrollIntoView({ behavior: 'smooth', block: 'center' });
+          }
+        } catch (fallbackError) {
+          console.warn("🔍 PDF: Fallback navigation failed:", fallbackError);
+        }
+        return;
+      }
+    } catch (error) {
+      console.warn("🔍 PDF: Error in scrollToPageIndex:", error);
     }
-    jumpToIndex(idx);
-  }).current;
+    
+    // Retry with delay if elements aren't ready
+    setTimeout(() => scrollToPageIndex(zeroBasedIndex, attempts - 1), 150);
+  };
 
+  // Expose highlight API to global window for agent access
   useEffect(() => {
-    if (typeof currentPage === 'number' && currentPage > 0) {
-      requestJump(currentPage - 1);
+    if (typeof window !== 'undefined') {
+      window.pdfHighlighter = {
+        addHighlight: (highlight: any) => {
+          console.log("🎯 PDF API: Adding highlight:", highlight);
+          // This function is no longer used as we removed custom highlighting
+        },
+        removeHighlight: (id: string) => {
+          console.log("🎯 PDF API: Removing highlight:", id);
+          // This function is no longer used as we removed custom highlighting
+        },
+        clearHighlights: () => {
+          console.log("🎯 PDF API: Clearing all highlights and circles");
+          try {
+            if (searchPluginInstanceRef.current) {
+              searchPluginInstanceRef.current.clearHighlights();
+              console.log("🎯 PDF API: All highlights cleared successfully");
+            } else {
+              console.warn("🎯 PDF API: Search plugin not available for clearing highlights");
+            }
+            // Also clear circles
+            clearAllCircles();
+            console.log("🎯 PDF API: All circles cleared successfully");
+          } catch (error) {
+            console.error("🎯 PDF API: Error clearing highlights/circles:", error);
+          }
+        },
+        goToPage: (pageNumber: number) => {
+          console.log("🎯 PDF API: Going to page:", pageNumber);
+          if (onPageChange) {
+            onPageChange(pageNumber);
+          }
+        },
+        searchAndHighlight: async (searchTerm: string, options: any) => {
+          console.log("🎯 PDF API: Searching for text:", searchTerm);
+          
+          if (!searchTerm || !searchPluginInstanceRef.current) {
+            console.warn("🎯 PDF API: Invalid search term or plugin not available");
+            if (options.onSearchComplete) {
+              options.onSearchComplete([]);
+            }
+            return;
+          }
+
+          try {
+            // Clear previous highlights first
+            searchPluginInstanceRef.current.clearHighlights();
+            
+            // Perform the actual search using react-pdf-viewer
+            const matches = await searchPluginInstanceRef.current.highlight([{
+              keyword: searchTerm,
+              matchCase: false
+            }]);
+            
+            console.log("🎯 PDF API: Real search results:", matches);
+            
+            // Convert matches to the expected format
+            const results = matches.map((match, index) => ({
+              text: searchTerm,
+              matchIndex: index,
+              pageIndex: match.pageIndex,
+              startIndex: match.startIndex,
+              endIndex: match.endIndex,
+              highlightAreas: [{
+                pageIndex: match.pageIndex,
+                left: 0, // react-pdf-viewer handles positioning internally
+                top: 0,
+                width: 100,
+                height: 2
+              }]
+            }));
+            
+            if (options.onSearchComplete) {
+              options.onSearchComplete(results);
+            }
+            
+            // Jump to first match if found
+            if (matches.length > 0) {
+              searchPluginInstanceRef.current.jumpToMatch(0);
+            }
+            
+          } catch (error) {
+            console.error("🎯 PDF API: Search failed:", error);
+            if (options.onSearchComplete) {
+              options.onSearchComplete([]);
+            }
+          }
+        }
+      };
     }
-  }, [currentPage, requestJump]);
 
-  // Listen for external navigation events
-  useEffect(() => {
-    const handler = (e: any) => {
-      const idx = Math.max(0, Number(e?.detail?.pageNumber ?? 0));
-      requestJump(idx);
+    return () => {
+      if (typeof window !== 'undefined') {
+        delete window.pdfHighlighter;
+      }
     };
-    window.addEventListener('pdf-navigate-page', handler as EventListener);
-    return () => window.removeEventListener('pdf-navigate-page', handler as EventListener);
-  }, [requestJump]);
+  }, [onPageChange]);
 
-  // Support jumping to a specific search match (index) for tools/agent
+  // Listen for direct highlight events from agent (fallback)
   useEffect(() => {
-    const handler = (e: any) => {
-      const index = Math.max(0, Number(e?.detail?.index ?? 0));
-      try { (search as any).jumpToMatch?.(index); } catch {}
+    const handleNavigatePage = (event: any) => {
+      console.log("🧭 PDF: Received navigate page event:", event.detail);
+      const zeroBased = event.detail.pageNumber;
+      if (!isDocLoaded) {
+        pendingNavRef.current = zeroBased;
+        // Also store globally in case this component remounts
+        (window as any).__pendingPdfNav = zeroBased;
+        return;
+      }
+      try {
+        pageNavigationPluginInstance.jumpToPage(zeroBased);
+        scrollToPageIndex(zeroBased);
+      } catch (e) {
+      if (onPageChange) {
+          onPageChange(zeroBased + 1);
+        }
+        scrollToPageIndex(zeroBased);
+      }
     };
-    window.addEventListener('pdf-jump-to', handler as EventListener);
-    return () => window.removeEventListener('pdf-jump-to', handler as EventListener);
-  }, [search]);
 
-  
+    window.addEventListener('pdf-navigate-page', handleNavigatePage);
 
-  // Provide a global helper for direct page jumps (1-based)
-  useEffect(() => {
-    if (typeof window === 'undefined') return;
-    (window as any).pdfJumpToPage = (oneBased: number) => {
-      const idx = Math.max(0, (Number(oneBased) || 1) - 1);
-      requestJump(idx);
+    return () => {
+      window.removeEventListener('pdf-navigate-page', handleNavigatePage);
     };
-    return () => { try { delete (window as any).pdfJumpToPage; } catch {} };
-  }, [requestJump]);
+  }, [onPageChange]);
 
-  // Expose simple global highlight functions using the search + highlight plugins
+  // Convert annotations to react-pdf-viewer highlights
   useEffect(() => {
-    if (typeof window === 'undefined') return;
-    const api = {
-      highlightText: async (textOrTexts: string | string[], options?: { matchCase?: boolean }) => {
-        const texts = Array.isArray(textOrTexts) ? textOrTexts : [textOrTexts];
-        const terms = texts.map((t) => String(t || '').trim()).filter(Boolean);
-        if (terms.length === 0) return 0;
-        try {
-          // Ensure the PDF is ready before attempting to highlight
-          if (!(window as any).__pdfReady) {
-            await new Promise<void>((resolve) => {
-              const once = () => {
-                window.removeEventListener('pdf-ready', once as EventListener);
-                resolve();
-              };
-              window.addEventListener('pdf-ready', once as EventListener, { once: true });
-            });
-          }
-          try { (search as any).clearHighlights?.(); } catch {}
-          // Build robust keyword variants for better matching
-          const buildVariants = (t: string): (string)[] => {
-            const variants = new Set<string>();
-            const base = t.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
-            if (base) variants.add(base);
-            // Remove punctuation-only edges
-            variants.add(base.replace(/[\u201C\u201D\u2018\u2019"'`]+/g, ''));
-            // Replace hyphen-like chars with space
-            const noHyphen = base.replace(/[\-\u2010-\u2015\u2212\u00AD]/g, ' ');
-            variants.add(noHyphen);
-            // Shorten very long snippets into overlapping windows (30-60 chars)
-            if (base.length > 80) {
-              for (let i = 0; i < Math.min(base.length, 180); i += 35) {
-                const win = base.slice(i, i + 55).trim();
-                if (win.split(' ').length >= 3) variants.add(win);
+    // This useEffect is no longer needed as we removed custom highlighting
+  }, []);
+
+  // REMOVED: Custom highlight render functions that were creating random boxes
+  // We now only use searchPlugin's native text highlighting
+
+  // Create plugins (stable instance) with simple, clean highlighting
+  const searchPluginInstanceRef = useRef(searchPlugin({ 
+    enableShortcuts: true,
+    keyword: ''
+  }));
+  const searchPluginInstance = searchPluginInstanceRef.current;
+  const pageNavigationPluginInstanceRef = useRef(pageNavigationPlugin());
+  const pageNavigationPluginInstance = pageNavigationPluginInstanceRef.current;
+ 
+  // Utility: draw a circular overlay on a page using pixel rect relative to page layer
+  const drawCircleOnPage = (pageIndex: number, rect: { left: number; top: number; width: number; height: number }) => {
+    const layer = document.querySelector(`[data-testid="core__page-layer-${pageIndex}"]`) as HTMLElement | null;
+    if (!layer) return;
+    let container = layer.querySelector('.tutor-circle-overlay-container') as HTMLElement | null;
+    if (!container) {
+      container = document.createElement('div');
+      container.className = 'tutor-circle-overlay-container';
+      Object.assign(container.style, {
+        position: 'absolute',
+        inset: '0px',
+        pointerEvents: 'none',
+        zIndex: '9999',
+      } as CSSStyleDeclaration);
+      layer.appendChild(container);
+    }
+    const el = document.createElement('div');
+    el.className = 'tutor-circle-annotation';
+    Object.assign(el.style, {
+      position: 'absolute',
+      left: `${rect.left}px`,
+      top: `${rect.top}px`,
+      width: `${rect.width}px`,
+      height: `${rect.height}px`,
+      border: '3px solid #ef4444',
+      borderRadius: '9999px',
+      boxShadow: '0 0 0 2px rgba(239,68,68,0.25)',
+    } as CSSStyleDeclaration);
+    container.appendChild(el);
+  };
+
+  const clearAllCircles = () => {
+    document.querySelectorAll('.tutor-circle-overlay-container').forEach((el) => el.remove());
+  };
+
+  // REMOVED: highlightPlugin that was creating random boxes
+  // Only use searchPlugin's native highlighting for actual text content
+
+  const defaultLayoutPluginInstance = useRef(defaultLayoutPlugin({
+    sidebarTabs: (defaultTabs) => [
+      defaultTabs[0], // Thumbnails
+      defaultTabs[1], // Bookmarks
+    ],
+  })).current;
+
+  // Utility: find a text occurrence inside an element and return its DOMRange and page-relative rect
+  const normalizeSpaces = (s: string) => s.replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
+  const findTextRectInElement = (root: HTMLElement, term: string): { rect: DOMRect; range: Range } | null => {
+    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
+    const lowerTerm = normalizeSpaces(term.toLowerCase());
+    let node: Node | null = walker.nextNode();
+    while (node) {
+      const text = normalizeSpaces(node.nodeValue || '');
+      if (text) {
+        const idx = text.toLowerCase().indexOf(lowerTerm);
+        if (idx !== -1) {
+          try {
+            const range = document.createRange();
+            // Map idx back to original node offsets by scanning original string
+            const original = (node.nodeValue || '').replace(/\u00a0/g, ' ');
+            // Best effort: find the substring position ignoring repeated spaces
+            let oi = 0, ti = 0, start = -1, end = -1;
+            const target = lowerTerm;
+            const lowerOriginal = original.toLowerCase();
+            while (oi < lowerOriginal.length && ti < target.length) {
+              const oc = lowerOriginal[oi];
+              const tc = target[ti];
+              if (/\s/.test(oc) && /\s/.test(tc)) {
+                // consume contiguous spaces
+                while (oi < lowerOriginal.length && /\s/.test(lowerOriginal[oi])) oi++;
+                while (ti < target.length && /\s/.test(target[ti])) ti++;
+                if (start === -1) start = oi;
+                continue;
               }
-            }
-            // Use top words (length > 3), create 3- to 5-grams
-            const words = base.split(/\s+/).filter(w => w.replace(/[^A-Za-z0-9]/g, '').length > 3).slice(0, 20);
-            for (let n = 5; n >= 3; n--) {
-              for (let i = 0; i + n <= Math.min(words.length, 12); i++) {
-                const gram = words.slice(i, i + n).join(' ');
-                if (gram.length >= 12) variants.add(gram);
+              if (oc === tc) {
+                if (start === -1) start = oi;
+                oi++; ti++;
+              } else {
+                // Not matching, break
+                start = -1; end = -1; break;
               }
             }
-            // Cap variants to avoid excessive DOM work
-            return Array.from(variants).slice(0, 50);
+            if (start !== -1 && ti === target.length) {
+              end = oi;
+            } else {
+              start = idx; end = idx + lowerTerm.length;
+            }
+            range.setStart(node, Math.max(0, start));
+            range.setEnd(node, Math.min((node.nodeValue || '').length, end));
+            const rect = range.getBoundingClientRect();
+            return { rect, range };
+          } catch {}
+        }
+      }
+      node = walker.nextNode();
+    }
+    return null;
+  };
+
+  // Utility: clear prior overlays within this viewer
+  const clearCircleOverlays = () => {
+    const container = rootRef.current;
+    if (!container) return;
+    const overlays = container.querySelectorAll('[data-circle-overlay="1"]');
+    overlays.forEach((el) => el.parentElement?.removeChild(el));
+  };
+
+  // Listen for events to circle a specific text (e.g., "Table 1")
+  useEffect(() => {
+    const process = (detail: any, attempts = 10) => {
+      const eventDetail = detail || {};
+      const text = eventDetail.text as string | undefined;
+      const oneBasedPage = eventDetail.page as number | undefined;
+      if (!text || !rootRef.current) return;
+
+      const pages: HTMLElement[] = Array.from(
+        rootRef.current.querySelectorAll('[data-testid^="core__page-layer-"]')
+      ) as HTMLElement[];
+
+      if (pages.length === 0) {
+        console.log('🔴 pdf-circle-text: pages not ready, retrying...', { attempts });
+        if (attempts > 0) setTimeout(() => process(eventDetail, attempts - 1), 150);
+        return;
+      }
+
+      console.log('🟢 pdf-circle-text: searching', { text, page: oneBasedPage, pageCount: pages.length });
+      clearCircleOverlays();
+
+      const zeroBased = typeof oneBasedPage === 'number' && oneBasedPage > 0 ? oneBasedPage - 1 : undefined;
+      const indices = zeroBased !== undefined ? [zeroBased] : pages.map((_, i) => i);
+      const tryTerms = [text, text.replace(/\s+/g, ' ')];
+      for (const i of indices) {
+        const pageEl = pages[i];
+        if (!pageEl) continue;
+        let found: { rect: DOMRect; range: Range } | null = null;
+        for (const t of tryTerms) {
+          found = findTextRectInElement(pageEl, t);
+          if (found) break;
+        }
+        // Fallback: try just the word 'Table' part to still provide a cue
+        if (!found) {
+          const wordOnly = (text.match(/^[A-Za-z]+/) || [])[0];
+          if (wordOnly) found = findTextRectInElement(pageEl, wordOnly);
+        }
+        if (found) {
+          console.log('✅ pdf-circle-text: found match on page', i + 1);
+          const layerRect = pageEl.getBoundingClientRect();
+          const localRect = {
+            left: found.rect.left - layerRect.left,
+            top: found.rect.top - layerRect.top,
+            width: found.rect.width,
+            height: found.rect.height,
           };
-          const allVariants = Array.from(new Set(terms.flatMap(buildVariants)));
-          const keywords = allVariants.map((k) => ({ keyword: k, matchCase: Boolean(options?.matchCase) }));
-          const matches: any[] = await (search as any).highlight?.(keywords as any);
+          drawCircleOnPage(i, localRect);
+          try { scrollToPageIndex(i); } catch {}
+          return;
+        }
+      }
+      if (attempts > 0) setTimeout(() => process(eventDetail, attempts - 1), 150);
+    };
 
-          // Debug: log match summary
-          try {
-            const pages = Array.from(new Set((matches || []).map((m: any) => m.pageIndex))).sort((a, b) => a - b);
-            console.log('[PDF] highlightText: matches', { count: matches?.length || 0, pages });
-          } catch {}
+    const handler = (event: any) => {
+      const text = event?.detail?.text as string | undefined;
+      const oneBasedPage = event?.detail?.page as number | undefined;
+      if (!text) return;
+      console.log('📩 pdf-circle-text event received', { text, page: oneBasedPage });
+      process({ text, page: oneBasedPage });
+    };
+    window.addEventListener('pdf-circle-text', handler);
+    return () => window.removeEventListener('pdf-circle-text', handler);
+  }, []);
+
+  // Expose a stable global jump function for external callers (agent/session)
+  useEffect(() => {
+    if (typeof window === 'undefined') return;
+    const api: any = window as any;
+    api.pdfJumpToPage = (oneBasedPage: number) => {
+      const zeroBased = Math.max(0, (oneBasedPage || 1) - 1);
+      if (!isDocLoaded) {
+        pendingNavRef.current = zeroBased;
+        api.__pendingPdfNav = zeroBased;
+        return;
+      }
+      try {
+        pageNavigationPluginInstance.jumpToPage(zeroBased);
+      } catch {}
+      scrollToPageIndex(zeroBased);
+    };
+    
+    // Configure auto-advance settings
+    api.__pdfAutoAdvance = {
+      intervalMs: 3500,
+      enabled: true
+    };
+    
+    return () => {
+      try { delete (window as any).pdfJumpToPage; } catch {}
+    };
+  }, [isDocLoaded, pageNavigationPluginInstance]);
 
-          // If there are matches, compute the first target page using the plugin's results (not DOM)
-          if (Array.isArray(matches) && matches.length > 0) {
-            const sorted = matches.slice().sort((a: any, b: any) =>
-              (a.pageIndex - b.pageIndex) || (a.startIndex - b.startIndex) || (a.matchIndex - b.matchIndex)
-            );
-            const first = sorted[0];
+  // Highlight queue to prevent conflicts
+  const highlightQueueRef = useRef<Array<{ requestId: string; keywords: any; timestamp: number }>>([]);
+  const processingHighlightRef = useRef<boolean>(false);
 
-            // Jump to the first true match page and also focus the exact match
-            try {
-              requestJump(first.pageIndex);
-            } catch {}
-
-            // Allow DOM to render highlights on that page, then collect rectangles only from that page
-            const collectAndRender = async (targetPageIndex: number, retries: number): Promise<number> => {
-              await new Promise((r) => setTimeout(r, 140));
-              const pageLayer = document.querySelector(`[data-testid="core__page-layer-${targetPageIndex}"]`) as HTMLElement | null;
-              if (!pageLayer) {
-                if (retries > 0) return collectAndRender(targetPageIndex, retries - 1);
-                return matches.length;
-              }
-              const nodes = Array.from(pageLayer.querySelectorAll('.rpv-search__highlight, [data-testid^="search__highlight-"], .rpv-search__highlight--focused')) as HTMLElement[];
-              if (nodes.length === 0) {
-                if (retries > 0) return collectAndRender(targetPageIndex, retries - 1);
-                return matches.length;
-              }
+  const processHighlightQueue = async () => {
+    if (processingHighlightRef.current || highlightQueueRef.current.length === 0) {
+      return;
+    }
 
-              const grouped: Record<number, Array<{ left: number; top: number; width: number; height: number }>> = {};
-              const layerRect = pageLayer.getBoundingClientRect();
-              for (const n of nodes) {
-                const r = n.getBoundingClientRect();
-                const left = r.left - layerRect.left;
-                const top = r.top - layerRect.top;
-                const width = r.width;
-                const height = r.height;
-                const wr = layerRect.width || 1;
-                const hr = layerRect.height || 1;
-                const leftRatio = Math.max(0, Math.min(1, left / wr));
-                const topRatio = Math.max(0, Math.min(1, top / hr));
-                const widthRatio = Math.max(0, Math.min(1, width / wr));
-                const heightRatio = Math.max(0, Math.min(1, height / hr));
-                if (!grouped[targetPageIndex]) grouped[targetPageIndex] = [];
-                grouped[targetPageIndex].push({ left: leftRatio, top: topRatio, width: widthRatio, height: heightRatio });
-              }
+    processingHighlightRef.current = true;
+    const currentRequest = highlightQueueRef.current.shift();
+    
+    if (!currentRequest) {
+      processingHighlightRef.current = false;
+      return;
+    }
 
-              // Replace built-in highlights with our overlay, but keep plugin highlights visible
-              hlAreasRef.current = grouped;
-              setHlAreas(grouped);
-              // Do not clear search highlights so they remain visible
+    const { requestId, keywords: reqKeywords } = currentRequest;
+    console.log("🔍 PDF: Processing highlight request:", { requestId, keywords: reqKeywords });
 
-              // Publish semantic steps for this page (first area only)
-              try {
-                const firstArea = grouped[targetPageIndex]?.[0];
-                (window as any).__semanticSteps = firstArea ? [{ pageIndex: targetPageIndex, rect: firstArea }] : [];
-              } catch {}
+    try {
+      // Clear previous highlights
+      if (searchPluginInstanceRef.current) {
+        searchPluginInstanceRef.current.clearHighlights();
+        console.log("🔍 PDF: Previous highlights cleared");
+      }
+      
+      // Only clear circles for new search operations, not for quote highlighting
+      const isQuoteHighlight = currentRequest.requestId.includes('quote-highlight');
+      if (!isQuoteHighlight) {
+        clearAllCircles();
+        console.log("🔍 PDF: Previous circles cleared (new search operation)");
+      } else {
+        console.log("🔍 PDF: Keeping circles visible (quote highlighting)");
+      }
 
-              return nodes.length;
-            };
+      // Small delay to ensure clearing is complete
+      await new Promise(resolve => setTimeout(resolve, 50));
 
-            await collectAndRender(first.pageIndex, 3);
-            return matches.length;
-          }
+      if (!searchPluginInstanceRef.current) {
+        console.error("🔍 PDF: Search plugin instance not available");
+        return;
+      }
+      
+      const matches = await searchPluginInstanceRef.current.highlight(reqKeywords as any);
+      console.log("🔍 PDF: Real search results found:", matches.length, "matches");
+      
+      const results = matches.map((m, i) => {
+        const text = m.pageText || '';
+        const contextStart = Math.max(0, m.startIndex - 80);
+        const contextEnd = Math.min(text.length, m.endIndex + 80);
+        const excerpt = text.slice(contextStart, contextEnd);
+        const matchedText = text.slice(m.startIndex, m.endIndex);
+        
+        console.log(`🔍 PDF: Match ${i + 1} on page ${m.pageIndex + 1}: "${matchedText}" (${m.startIndex}-${m.endIndex})`);
+        
+        return {
+          pageIndex: m.pageIndex,
+          page: m.pageIndex + 1,
+          matchIndex: m.matchIndex,
+          globalIndex: i,
+          startIndex: m.startIndex,
+          endIndex: m.endIndex,
+          excerpt,
+          matchedText,
+        };
+      });
+      
+      console.log("🔍 PDF: Processed real search results:", results.length, "total matches");
+      window.dispatchEvent(new CustomEvent('pdf-search-results', {
+        detail: { requestId, results }
+      }));
+      
+    } catch (err) {
+      console.error('🔍 PDF: Search request failed', err);
+      window.dispatchEvent(new CustomEvent('pdf-search-results', {
+        detail: { requestId, results: [] }
+      }));
+    } finally {
+      processingHighlightRef.current = false;
+      // Process next item in queue after a small delay
+      setTimeout(processHighlightQueue, 100);
+    }
+  };
 
-          // No matches – clear any overlay and return 0
-          hlAreasRef.current = {};
-          setHlAreas({});
-          return 0;
-        } catch {
-          return 0;
+  // Listen for search-related events from the agent/UI
+  useEffect(() => {
+    const handleSearchRequest = async (event: any) => {
+      const requestId = event?.detail?.requestId;
+      const reqKeywords = event?.detail?.keywords as SingleKeyword | SingleKeyword[];
+      console.log("🔍 PDF: Search request received and queued:", { requestId, keywords: reqKeywords });
+      console.log("🔍 PDF: Event detail:", event.detail);
+      
+      if (!reqKeywords) {
+        console.warn("🔍 PDF: No keywords provided for search");
+        return;
+      }
+      
+      // Add to queue instead of processing immediately
+      highlightQueueRef.current.push({
+        requestId,
+        keywords: reqKeywords,
+        timestamp: Date.now()
+      });
+      
+      // Start processing queue
+      processHighlightQueue();
+    };
+
+    const handleSetKeywords = async (event: any) => {
+      const newKeywords = event?.detail?.keywords as SingleKeyword | SingleKeyword[];
+      console.log("🔍 PDF: Setting keywords:", newKeywords);
+      lastKeywordsRef.current = newKeywords;
+      
+      // Also apply highlighting immediately when keywords are set
+      if (newKeywords && searchPluginInstanceRef.current) {
+        try {
+          console.log("🔍 PDF: Applying keywords for highlighting:", newKeywords);
+          await searchPluginInstanceRef.current.highlight(newKeywords as any);
+          console.log("🔍 PDF: Keywords applied successfully");
+        } catch (err) {
+          console.error("🔍 PDF: Failed to apply keywords:", err);
         }
-      },
-      highlightSnippets: async (snippets: string[], options?: { matchCase?: boolean }) => {
-        snippets.forEach(snippet => { console.log("Snippet:", snippet, options); });
-        return api.highlightText(snippets, options);
-      },
-      clearHighlights: () => {
-        setHlAreas({});
       }
-    } as const;
+    };
 
-    (window as any).pdfHighlighter = {
-      ...(window as any).pdfHighlighter,
-      ...api,
+    const handleJumpTo = (event: any) => {
+      const index = typeof event?.detail?.index === 'number' ? event.detail.index : 0;
+      let attempts = 0;
+      const tryJump = async () => {
+        try {
+          if (!searchPluginInstanceRef.current) {
+            console.error("🔍 PDF: Search plugin instance not available for jump");
+            return;
+          }
+          const result = searchPluginInstanceRef.current.jumpToMatch(index);
+          if (!result && attempts < 5) {
+            attempts += 1;
+            // Re-apply highlights if needed, then retry
+            const kw = lastKeywordsRef.current;
+            if (kw && searchPluginInstanceRef.current) {
+              try { await searchPluginInstanceRef.current.highlight(kw as any); } catch {}
+            }
+            setTimeout(tryJump, 150);
+          }
+        } catch (e) {
+          if (attempts < 5) {
+            attempts += 1;
+            const kw = lastKeywordsRef.current;
+            if (kw && searchPluginInstanceRef.current) {
+              try { await searchPluginInstanceRef.current.highlight(kw as any); } catch {}
+            }
+            setTimeout(tryJump, 150);
+          }
+        }
+      };
+      tryJump();
     };
 
-    // Backup: respond to semantic-snippets events by (re)highlighting
-    const onSemanticSnippets = async (ev: any) => {
-      try {
-        const snippets: string[] = Array.isArray(ev?.detail?.snippets) ? ev.detail.snippets : [];
-        if (!snippets.length) return;
-        // Wait for viewer readiness if not ready yet
-        if (!(window as any).__pdfReady) {
-          const once = () => {
-            window.removeEventListener('pdf-ready', once as EventListener);
-            setTimeout(() => { (window as any).pdfHighlighter?.highlightText?.(snippets); }, 50);
-          };
-          window.addEventListener('pdf-ready', once as EventListener, { once: true });
-          return;
+    const handleClearHighlights = () => {
+      try { 
+        if (searchPluginInstanceRef.current) {
+          searchPluginInstanceRef.current.clearHighlights(); 
         }
-        await (window as any).pdfHighlighter?.highlightText?.(snippets);
+        // Only clear circles if explicitly requested via 'tutor-annotations-clear' event
+        // Don't automatically clear circles with every highlight clear
+        console.log("🔍 PDF: Cleared highlights (circles preserved)");
       } catch {}
     };
-    window.addEventListener('semantic-snippets', onSemanticSnippets as EventListener);
 
-    // Allow external jump to a specific semantic step index
-    const onSemanticJump = (ev: any) => {
+    window.addEventListener('pdf-search-request', handleSearchRequest);
+    window.addEventListener('pdf-set-keywords', handleSetKeywords);
+    window.addEventListener('pdf-jump-to', handleJumpTo);
+    window.addEventListener('pdf-clear-highlights', handleClearHighlights);
+
+    return () => {
+      window.removeEventListener('pdf-search-request', handleSearchRequest);
+      window.removeEventListener('pdf-set-keywords', handleSetKeywords);
+      window.removeEventListener('pdf-jump-to', handleJumpTo);
+      window.removeEventListener('pdf-clear-highlights', handleClearHighlights);
+    };
+  }, []);
+
+  // Listen for requests to circle a table label (e.g., "Table 1") and highlight quotes
+  useEffect(() => {
+    // Function to get actual table boundaries from PDF structure
+    const getTableBoundariesFromPDF = async (pageIndex: number, labelText: string) => {
       try {
-        const idx = Math.max(0, Number(ev?.detail?.index ?? 0));
-        jumpToIndex(idx);
-      } catch {}
+        console.log(`🎯 Analyzing PDF structure for table: ${labelText} on page ${pageIndex + 1}`);
+        
+        // Access the PDF document from the viewer
+        const pdfDoc = (window as any).__pdfDocument;
+        if (!pdfDoc) {
+          console.log('🎯 PDF document not available for structure analysis');
+          return null;
+        }
+        
+        const page = await pdfDoc.getPage(pageIndex + 1);
+        const textContent = await page.getTextContent();
+        const viewport = page.getViewport({ scale: 1 });
+        
+        // Find the label position in the text content
+        let labelItem = null;
+        let labelIndex = -1;
+        
+        for (let i = 0; i < textContent.items.length; i++) {
+          const item = textContent.items[i];
+          if (item.str && item.str.toLowerCase().includes(labelText.toLowerCase())) {
+            labelItem = item;
+            labelIndex = i;
+            break;
+          }
+        }
+        
+        if (!labelItem) {
+          console.log('🎯 Label not found in PDF text content');
+          return null;
+        }
+        
+        console.log(`🎯 Found label at index ${labelIndex}:`, labelItem);
+        
+        // Analyze items after the label to find table structure
+        const tableItems = [];
+        const labelY = labelItem.transform[5]; // Y coordinate
+        const labelX = labelItem.transform[4]; // X coordinate
+        
+        // Look for structured content below the label
+        for (let i = labelIndex + 1; i < textContent.items.length; i++) {
+          const item = textContent.items[i];
+          const itemY = item.transform[5];
+          const itemX = item.transform[4];
+          
+          // Stop if we've moved too far down - tables are usually much closer
+          if (labelY - itemY > 100) break; // Much more restrictive: only 100 units below label
+          
+          // Much more restrictive: Only include actual table content
+          if (item.str && (
+            /^\d+\.?\d*$/.test(item.str.trim()) || // Pure numbers (table data)
+            /^[A-Z][a-z]+$/.test(item.str.trim()) || // Model names like "AED", "Transformer"
+            item.str.includes('M') || // Parameter counts like "116.2M"
+            /^[a-z]+$/.test(item.str.trim()) && item.str.length < 10 || // Short lowercase (like "clean", "test")
+            Math.abs(itemX - labelX) < 150 // Much closer horizontal alignment for table cells
+          )) {
+            tableItems.push({
+              text: item.str,
+              x: itemX,
+              y: itemY,
+              width: item.width || 0,
+              height: item.height || 0
+            });
+          }
+        }
+        
+        if (tableItems.length === 0) {
+          console.log('🎯 No table items found after label');
+          return null;
+        }
+        
+        // Calculate actual table boundaries
+        const minX = Math.min(labelX, ...tableItems.map(item => item.x));
+        const maxX = Math.max(labelX + (labelItem.width || 0), ...tableItems.map(item => item.x + item.width));
+        const minY = Math.min(labelY, ...tableItems.map(item => item.y));
+        const maxY = Math.max(labelY, ...tableItems.map(item => item.y));
+        
+        console.log(`🎯 PDF structure analysis - Table bounds: ${minX}, ${minY} to ${maxX}, ${maxY}`);
+        
+        return {
+          left: minX,
+          top: maxY, // PDF coordinates are flipped
+          right: maxX,
+          bottom: minY,
+          width: maxX - minX,
+          height: labelY - minY // Height in PDF coordinates
+        };
+        
+      } catch (error) {
+        console.error('🎯 Error analyzing PDF structure:', error);
+        return null;
+      }
     };
-    window.addEventListener('semantic-jump-to', onSemanticJump as EventListener);
 
+    const circleByLabel = (label: string) => {
+      console.log(`🎯 Circling label with PDF structure analysis: ${label}`);
+      
+      const requestId = `circle-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+      const onResults = (e: any) => {
+        if (e?.detail?.requestId !== requestId) return;
+        window.removeEventListener('pdf-search-results', onResults as EventListener);
+        const results = (e?.detail?.results || []) as Array<{ pageIndex: number; matchIndex: number }>;
+        if (!results.length) {
+          console.log(`🎯 No search results found for label: ${label}`);
+          return;
+        }
+        
+        const first = results[0];
+        console.log(`🎯 Found label on page ${first.pageIndex + 1}, analyzing structure...`);
+        
+        setTimeout(async () => {
+          try {
+            const layer = document.querySelector(`[data-testid="core__page-layer-${first.pageIndex}"]`) as HTMLElement | null;
+            if (!layer) {
+              console.log(`🎯 Could not find page layer for page ${first.pageIndex}`);
+              return;
+            }
+
+            // Try PDF structure analysis first
+            const pdfBounds = await getTableBoundariesFromPDF(first.pageIndex, label);
+            if (pdfBounds) {
+              console.log(`🎯 Using PDF structure bounds:`, pdfBounds);
+              
+              // Convert PDF coordinates to screen coordinates
+              const layerRect = layer.getBoundingClientRect();
+              // For now, use a simple approach - just circle a reasonable area around the label
+              const hlEls = layer.querySelectorAll('.rpv-search__highlight');
+              if (hlEls && hlEls.length > 0) {
+                const firstHl = hlEls[0] as HTMLElement;
+                const hlRect = firstHl.getBoundingClientRect();
+                const labelLeft = hlRect.left - layerRect.left;
+                const labelTop = hlRect.top - layerRect.top;
+                
+                // Create a much smaller, more precise circle
+                const padding = 20;
+                const circleWidth = Math.min(300, layerRect.width * 0.4); // Max 300px or 40% of page
+                const circleHeight = Math.min(200, layerRect.height * 0.25); // Max 200px or 25% of page
+                
+                drawCircleOnPage(first.pageIndex, {
+                  left: Math.max(0, labelLeft - padding),
+                  top: Math.max(0, labelTop - padding),
+                  width: circleWidth,
+                  height: circleHeight,
+                });
+                
+                console.log(`🎯 Drew precise table circle: ${circleWidth}x${circleHeight} at ${labelLeft}, ${labelTop}`);
+                return;
+              }
+            }
+            
+            const hlEls = layer.querySelectorAll('.rpv-search__highlight');
+            if (!hlEls || hlEls.length === 0) {
+              console.log(`🎯 No highlight elements found for ${label}`);
+              return;
+            }
+            
+            console.log(`🎯 Found ${hlEls.length} highlight elements`);
+            
+            const layerRect = layer.getBoundingClientRect();
+            let minLeft = Number.POSITIVE_INFINITY;
+            let minTop = Number.POSITIVE_INFINITY;
+            let maxRight = 0;
+            let maxBottom = 0;
+            
+            // Get bounds of all highlighted elements (the label)
+            hlEls.forEach((n) => {
+              const r = (n as HTMLElement).getBoundingClientRect();
+              minLeft = Math.min(minLeft, r.left);
+              minTop = Math.min(minTop, r.top);
+              maxRight = Math.max(maxRight, r.right);
+              maxBottom = Math.max(maxBottom, r.bottom);
+            });
+            
+            if (!isFinite(minLeft) || !isFinite(minTop)) return;
+            
+            // Convert to page-relative coordinates
+            const labelLeft = minLeft - layerRect.left;
+            const labelTop = minTop - layerRect.top;
+            const labelWidth = maxRight - minLeft;
+            const labelHeight = maxBottom - minTop;
+            
+            console.log(`🎯 Label bounds: ${labelLeft}, ${labelTop}, ${labelWidth}x${labelHeight}`);
+            
+            // Advanced content-aware circle positioning
+            const isTable = /table/i.test(label);
+            const isFigure = /figure/i.test(label);
+            
+            // Analyze content structure for 2-column layout
+            const analyzeContentBounds = () => {
+              // Get all text elements in the page layer
+              const textElements = Array.from(layer.querySelectorAll('span, div')).filter(el => {
+                const text = el.textContent?.trim();
+                return text && text.length > 0;
+              });
+              
+              if (textElements.length === 0) {
+                console.log('🎯 No text elements found for content analysis');
+                return null;
+              }
+              
+              // Improved 2-column detection by analyzing actual text distribution
+              const pageWidth = layerRect.width;
+              
+              // Analyze text distribution to find the actual column boundary
+              const textPositions = textElements.map(el => {
+                const rect = el.getBoundingClientRect();
+                return rect.left - layerRect.left;
+              }).sort((a, b) => a - b);
+              
+              // Find the gap between columns by looking for the largest horizontal gap
+              let columnBoundary = pageWidth / 2; // Default fallback
+              let maxGap = 0;
+              
+              for (let i = 1; i < textPositions.length; i++) {
+                const gap = textPositions[i] - textPositions[i-1];
+                if (gap > maxGap && gap > 30) { // Minimum gap of 30px to be considered column separator
+                  maxGap = gap;
+                  columnBoundary = textPositions[i-1] + gap / 2;
+                }
+              }
+              
+              // Determine which column the label is in based on detected boundary
+              const isLeftColumn = labelLeft < columnBoundary;
+              const columnStart = isLeftColumn ? 0 : columnBoundary;
+              const columnEnd = isLeftColumn ? columnBoundary : pageWidth;
+              
+              console.log(`🎯 Detected column boundary at ${columnBoundary.toFixed(1)}px`);
+              console.log(`🎯 Label in ${isLeftColumn ? 'LEFT' : 'RIGHT'} column (${columnStart.toFixed(1)}-${columnEnd.toFixed(1)})`);
+              
+              // Enhanced table/figure content detection for 2-column layout
+              const contentElements = textElements.filter(el => {
+                const rect = el.getBoundingClientRect();
+                const elTop = rect.top - layerRect.top;
+                const elLeft = rect.left - layerRect.left;
+                const elRight = elLeft + rect.width;
+                
+                // Check if element is in the same column
+                const elementInColumn = isLeftColumn ? 
+                  (elLeft >= columnStart && elLeft < columnEnd) :
+                  (elLeft >= columnStart && elLeft < layerRect.width);
+                
+                if (!elementInColumn) return false;
+                
+                // For tables, look for structured content (rows, cells, data)
+                if (isTable) {
+                  // Tables: look for content below the label (table rows/data)
+                  const isBelow = elTop >= labelTop - 20; // Allow slight overlap
+                  const horizontalOverlap = !(elRight < labelLeft - 100 || elLeft > labelLeft + labelWidth + 100);
+                  
+                  // Much more restrictive for tables - only include elements very close to the table
+                  const isVeryClose = (elTop - labelTop) < 200; // Reduced from 500 to 200
+                  const hasTableLikeContent = el.textContent && (
+                    /\d/.test(el.textContent) || // Contains numbers (common in tables)
+                    el.textContent.length < 50 || // Short text (table cells)
+                    /[|─┌┐└┘├┤┬┴┼]/.test(el.textContent) // Table drawing characters
+                  );
+                  
+                  return isBelow && horizontalOverlap && isVeryClose && hasTableLikeContent;
+                } else if (isFigure) {
+                  // Figures: look for content around the label (captions, figure content)
+                  const verticalDistance = Math.abs(elTop - labelTop);
+                  const horizontalDistance = Math.abs(elLeft - labelLeft);
+                  
+                  return verticalDistance < 300 && horizontalDistance < (pageWidth / 2) * 0.8;
+                } else {
+                  // Generic: nearby content
+                  const verticalDistance = Math.abs(elTop - labelTop);
+                  const horizontalDistance = Math.abs(elLeft - labelLeft);
+                  
+                  return verticalDistance < 200 && horizontalDistance < (pageWidth / 2) * 0.7;
+                }
+              });
+              
+              if (contentElements.length === 0) {
+                console.log('🎯 No content elements found near label in same column');
+                return null;
+              }
+              
+              console.log(`🎯 Found ${contentElements.length} content elements in same column`);
+              
+              // For tables, try to find the actual table bottom boundary
+              let tableBottomY = labelTop;
+              if (isTable && contentElements.length > 0) {
+                // Sort elements by vertical position to find table structure
+                const sortedElements = contentElements
+                  .map(el => {
+                    const rect = el.getBoundingClientRect();
+                    return {
+                      element: el,
+                      top: rect.top - layerRect.top,
+                      bottom: rect.top - layerRect.top + rect.height,
+                      left: rect.left - layerRect.left,
+                      text: el.textContent?.trim() || ''
+                    };
+                  })
+                  .sort((a, b) => a.top - b.top);
+                
+                // Look for table patterns: repeated horizontal structures, similar spacing
+                const rowElements = [];
+                let lastRowY = -1;
+                const rowSpacing = [];
+                
+                for (const elem of sortedElements) {
+                  if (elem.top > labelTop) { // Only consider elements below the label
+                    if (lastRowY >= 0) {
+                      const spacing = elem.top - lastRowY;
+                      rowSpacing.push(spacing);
+                    }
+                    rowElements.push(elem);
+                    lastRowY = elem.top;
+                  }
+                }
+                
+                // Find the consistent row spacing to detect table end
+                if (rowSpacing.length > 1) {
+                  const avgSpacing = rowSpacing.reduce((a, b) => a + b, 0) / rowSpacing.length;
+                  const lastElement = rowElements[rowElements.length - 1];
+                  
+                  // Look for where spacing becomes inconsistent (table ends)
+                  for (let i = rowSpacing.length - 1; i >= 0; i--) {
+                    if (Math.abs(rowSpacing[i] - avgSpacing) > avgSpacing * 0.5) {
+                      // Found inconsistent spacing - table likely ends here
+                      tableBottomY = rowElements[i].bottom;
+                      break;
+                    }
+                  }
+                  
+                  // If no inconsistency found, use the last element
+                  if (tableBottomY === labelTop && lastElement) {
+                    tableBottomY = lastElement.bottom;
+                  }
+                  
+                  console.log(`🎯 Table analysis: avgSpacing=${avgSpacing.toFixed(1)}, tableBottom=${tableBottomY.toFixed(1)}`);
+                }
+              }
+              
+              // Calculate the bounding box of all related content within the column
+              let minX = Number.POSITIVE_INFINITY;
+              let minY = Number.POSITIVE_INFINITY;
+              let maxX = 0;
+              let maxY = 0;
+              
+              contentElements.forEach(el => {
+                const rect = el.getBoundingClientRect();
+                const elLeft = rect.left - layerRect.left;
+                const elTop = rect.top - layerRect.top;
+                const elRight = elLeft + rect.width;
+                const elBottom = elTop + rect.height;
+                
+                minX = Math.min(minX, elLeft);
+                minY = Math.min(minY, elTop);
+                maxX = Math.max(maxX, elRight);
+                maxY = Math.max(maxY, elBottom);
+              });
+              
+              // For tables, extend the bottom boundary significantly to capture full table
+              if (isTable) {
+                const detectedBottom = tableBottomY > labelTop ? tableBottomY : maxY;
+                // Extend bottom boundary by additional amount to ensure full table capture
+                const extendedBottom = detectedBottom + 100; // Add 100px more to bottom
+                maxY = Math.max(maxY, extendedBottom);
+                console.log(`🎯 Extended table bottom from ${detectedBottom} to ${extendedBottom}`);
+              }
+              
+              // Include the original label in the bounds
+              minX = Math.min(minX, labelLeft);
+              minY = Math.min(minY, labelTop);
+              maxX = Math.max(maxX, labelLeft + labelWidth);
+              maxY = Math.max(maxY, labelTop + labelHeight);
+              
+              // Constrain to column boundaries
+              minX = Math.max(columnStart + 10, minX);
+              maxX = Math.min(columnEnd - 10, maxX);
+              
+              console.log(`🎯 2-column content analysis: ${minX}, ${minY} to ${maxX}, ${maxY}`);
+              
+              return {
+                left: minX,
+                top: minY,
+                width: maxX - minX,
+                height: maxY - minY,
+                isLeftColumn
+              };
+            };
+            
+            const contentBounds = analyzeContentBounds();
+            let circleLeft, circleTop, circleWidth, circleHeight;
+            
+            if (contentBounds) {
+              // Use the analyzed content bounds with appropriate padding
+              const padding = isTable ? 15 : isFigure ? 20 : 10;
+              
+              circleLeft = Math.max(0, contentBounds.left - padding);
+              circleTop = Math.max(0, contentBounds.top - padding);
+              circleWidth = Math.min(layerRect.width - circleLeft - padding, 
+                                   contentBounds.width + padding * 2);
+              circleHeight = Math.min(layerRect.height - circleTop - padding,
+                                    contentBounds.height + padding * 2);
+              
+              console.log(`🎯 Using content-based bounds with ${padding}px padding`);
+            } else {
+              // Fallback to improved heuristic approach
+              console.log('🎯 Using fallback heuristic approach');
+              
+              if (isTable) {
+                // Tables: moderate width, extend down from label
+                const padding = 20;
+                circleLeft = Math.max(0, labelLeft - padding);
+                circleTop = Math.max(0, labelTop - padding / 2);
+                circleWidth = Math.min(layerRect.width - circleLeft - padding,
+                                     Math.max(labelWidth + padding * 4, 300));
+                circleHeight = Math.min(layerRect.height - circleTop - padding, 150);
+              } else if (isFigure) {
+                // Figures: more square, centered around label
+                const padding = 25;
+                const estimatedWidth = Math.max(labelWidth + padding * 4, 250);
+                const estimatedHeight = Math.max(100, estimatedWidth * 0.7);
+                
+                circleLeft = Math.max(0, labelLeft - estimatedWidth / 4);
+                circleTop = Math.max(0, labelTop - padding);
+                circleWidth = Math.min(layerRect.width - circleLeft - padding, estimatedWidth);
+                circleHeight = Math.min(layerRect.height - circleTop - padding, estimatedHeight);
+              } else {
+                // Generic: tight around label with minimal padding
+                const padding = 15;
+                circleLeft = Math.max(0, labelLeft - padding);
+                circleTop = Math.max(0, labelTop - padding);
+                circleWidth = Math.min(layerRect.width - circleLeft, labelWidth + padding * 2);
+                circleHeight = Math.min(layerRect.height - circleTop, labelHeight + padding * 2);
+              }
+            }
+            
+            console.log(`🎯 Circle bounds: ${circleLeft}, ${circleTop}, ${circleWidth}x${circleHeight}`);
+            
+            drawCircleOnPage(first.pageIndex, {
+              left: circleLeft,
+              top: circleTop,
+              width: circleWidth,
+              height: circleHeight,
+            });
+            
+            console.log(`🎯 Successfully circled ${label} on page ${first.pageIndex + 1}`);
+          } catch (error) {
+            console.error(`🎯 Error circling ${label}:`, error);
+          }
+        }, 120);
+      };
+      
+      window.addEventListener('pdf-search-results', onResults as EventListener, { once: true });
+      // Clear existing circles before creating new ones (but only for circle operations)
+      try { clearAllCircles(); } catch {}
+      
+      // Enhanced search with multiple variations of the label
+      const searchTerms = [label];
+      
+      // Add variations for better matching
+      if (label.toLowerCase().includes('table')) {
+        const num = label.match(/\d+/)?.[0];
+        if (num) {
+          searchTerms.push(`Table ${num}`);
+          searchTerms.push(`table ${num}`);
+          searchTerms.push(`TABLE ${num}`);
+        }
+      } else if (label.toLowerCase().includes('figure')) {
+        const num = label.match(/\d+/)?.[0];
+        if (num) {
+          searchTerms.push(`Figure ${num}`);
+          searchTerms.push(`figure ${num}`);
+          searchTerms.push(`FIGURE ${num}`);
+          searchTerms.push(`Fig. ${num}`);
+          searchTerms.push(`fig. ${num}`);
+        }
+      }
+      
+      console.log(`🎯 Searching for label variations:`, searchTerms);
+      
+      window.dispatchEvent(new CustomEvent('pdf-search-request', {
+        detail: { requestId, keywords: searchTerms }
+      }));
+    };
+
+    // Handle quote highlighting from TutorAgent
+    const handleHighlightQuote = (event: any) => {
+      const { text, page } = event.detail || {};
+      console.log('🎯 PDF: Received highlight quote request:', { text, page });
+      console.log('🎯 PDF: Full event detail:', event.detail);
+      
+      if (!text || typeof text !== 'string') {
+        console.warn('🎯 PDF: Invalid quote text:', text);
+        return;
+      }
+
+      // Use the search functionality to highlight the quote
+      const requestId = `quote-highlight-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+      
+      // Don't clear circles for quote highlighting - they can coexist
+      // clearAllCircles(); // Removed - let circles stay visible with quotes
+      console.log('🎯 PDF: Keeping circles visible during quote highlighting');
+      
+      // Add to highlight queue instead of immediate processing to prevent flashing
+      highlightQueueRef.current.push({
+        requestId,
+        keywords: [{ keyword: text.trim(), matchCase: false }],
+        timestamp: Date.now()
+      });
+      
+      // Process the queue
+      processHighlightQueue();
+
+      // If page is specified, navigate to that page
+      if (typeof page === 'number' && page > 0) {
+        const zeroBased = page - 1;
+        try {
+          if ((window as any).pdfJumpToPage) {
+            (window as any).pdfJumpToPage(page);
+          } else {
+            window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: zeroBased } }));
+          }
+        } catch (err) {
+          console.warn('🎯 PDF: Failed to navigate to page:', err);
+        }
+      }
+    };
+
+    const handleCircleTable = (event: any) => {
+      const label = String(event?.detail?.label || '').trim() || 'Table 1';
+      // Try to jump to the first detected page quickly once results return; circleByLabel will handle drawing
+      circleByLabel(label);
+    };
+    const handleCircleFigure = (event: any) => {
+      const label = String(event?.detail?.label || '').trim() || 'Figure 1';
+      circleByLabel(label);
+    };
+    const handleClearAnnotations = () => clearAllCircles();
+
+    window.addEventListener('tutor-circle-table', handleCircleTable as EventListener);
+    window.addEventListener('tutor-circle-figure', handleCircleFigure as EventListener);
+    window.addEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener);
+    window.addEventListener('tutor-highlight-quote', handleHighlightQuote as EventListener);
+    
     return () => {
+      window.removeEventListener('tutor-circle-table', handleCircleTable as EventListener);
+      window.removeEventListener('tutor-circle-figure', handleCircleFigure as EventListener);
+      window.removeEventListener('tutor-annotations-clear', handleClearAnnotations as EventListener);
+      window.removeEventListener('tutor-highlight-quote', handleHighlightQuote as EventListener);
+    };
+  }, []);
+
+  // React to keyword changes (only clear when empty; highlighting is driven by explicit requests)
+  useEffect(() => {
+    const hasNoKeywords =
+      lastKeywordsRef.current === undefined ||
+      (Array.isArray(lastKeywordsRef.current) && lastKeywordsRef.current.length === 0) ||
+      (typeof lastKeywordsRef.current === 'string' && lastKeywordsRef.current.trim() === '');
+
+    if (hasNoKeywords) {
       try {
-        if ((window as any).pdfHighlighter) {
-          delete (window as any).pdfHighlighter.highlightText;
-          delete (window as any).pdfHighlighter.highlightSnippets;
-          delete (window as any).pdfHighlighter.clearHighlights;
-        }
+        searchPluginInstanceRef.current.clearHighlights();
+        // Also clear circles when clearing all highlights
+        clearAllCircles();
+        console.log("🔍 PDF: Cleared highlights and circles due to no keywords");
       } catch {}
-      try { window.removeEventListener('semantic-snippets', onSemanticSnippets as EventListener); } catch {}
-      try { window.removeEventListener('semantic-jump-to', onSemanticJump as EventListener); } catch {}
-    };
-  }, [search, jumpToIndex]);
+    }
+  }, [lastKeywordsRef.current]);
 
   return (
-    <div className="w-full h-full">
+    <div ref={rootRef} className="w-full h-full">
+      <style>{`
+        /* Simple circle styling only */
+        .tutor-circle-annotation {
+          border: 3px solid #ef4444 !important;
+          box-shadow: 0 0 0 2px rgba(239,68,68,0.25) !important;
+        }
+      `}</style>
       <Worker workerUrl="/pdf.worker.js">
-        <Viewer
-          fileUrl={fileUrl}
-          plugins={[defaultLayout, pageNavigation, search, highlight]}
-          initialPage={Math.max(0, (currentPage || 1) - 1)}
-          onDocumentLoad={(e) => {
-            try {
-              (window as any).__pdfNumPages = e?.doc?.numPages ?? undefined;
-              (window as any).__pdfReady = true;
-              readyRef.current = true;
-              window.dispatchEvent(new CustomEvent('pdf-ready'));
-              // Reduce rubber-band overscroll in some browsers
-              const container = document.querySelector('[data-testid="core__inner-pages"]') as HTMLElement | null;
-              if (container) {
-                (container.style as any).overscrollBehavior = 'contain';
-              }
-              // Flush any pending jump
+        <div style={{ height: '100%' }}>
+          <Viewer
+            fileUrl={fileUrl}
+            plugins={[defaultLayoutPluginInstance, pageNavigationPluginInstance, searchPluginInstance]}
+            onDocumentLoad={(e) => {
+              setIsDocLoaded(true);
+              try {
+                (window as any).__pdfNumPages = e?.doc?.numPages ?? undefined;
+                window.dispatchEvent(new CustomEvent('pdf-doc-loaded', { detail: { numPages: e?.doc?.numPages } }));
+              } catch {}
+              // Signal readiness for external controllers
+              try {
+                (window as any).__pdfReady = true;
+                window.dispatchEvent(new CustomEvent('pdf-ready'));
+              } catch {}
+              // Extract outline (sections) and expose globally
+              (async () => {
+                try {
+                  console.log("🔍 PDF: Attempting to extract outline...");
+                  
+                  // Try multiple methods to get the outline
+                  let outline: any[] = [];
+                  
+                  // Method 1: Try getOutline()
+                  try {
+                    outline = await (e as any)?.doc?.getOutline?.();
+                    console.log("🔍 PDF: getOutline() result:", outline);
+                  } catch (err) {
+                    console.log("🔍 PDF: getOutline() failed:", err);
+                  }
+                  
+                  // Method 2: Try bookmarks if outline failed
+                  if (!outline || outline.length === 0) {
+                    try {
+                      outline = await (e as any)?.doc?.getBookmarks?.();
+                      console.log("🔍 PDF: getBookmarks() result:", outline);
+                    } catch (err) {
+                      console.log("🔍 PDF: getBookmarks() failed:", err);
+                    }
+                  }
+                  
+                  // Method 3: Try to extract from document info
+                  if (!outline || outline.length === 0) {
+                    try {
+                      const info = await (e as any)?.doc?.getMetadata?.();
+                      console.log("🔍 PDF: Document metadata:", info);
+                    } catch (err) {
+                      console.log("🔍 PDF: getMetadata() failed:", err);
+                    }
+                  }
+                  
+                  const flat: Array<{ title: string; pageIndex: number }> = [];
+                  if (Array.isArray(outline) && outline.length > 0) {
+                    const walk = async (items: any[]) => {
+                      for (const it of items) {
+                        let pageIndex: number | null = null;
+                        const dest = it?.dest;
+                        if (Array.isArray(dest) && dest[0]) {
+                          try { pageIndex = await (e as any).doc.getPageIndex(dest[0]); } catch {}
+                        }
+                        if (typeof pageIndex === 'number') {
+                          flat.push({ title: String(it.title || '').trim(), pageIndex });
+                        }
+                        if (Array.isArray(it.items) && it.items.length) {
+                          await walk(it.items);
+                        }
+                      }
+                    };
+                    await walk(outline);
+                  }
+                  
+                  console.log("🔍 PDF: Final extracted sections:", flat);
+                  (window as any).__pdfOutline = flat;
+                  window.dispatchEvent(new CustomEvent('pdf-outline', { detail: { sections: flat } }));
+                  
+                  // Also try to extract section-like content from page text
+                  if (flat.length === 0) {
+                    console.log("🔍 PDF: No outline found, attempting to extract sections from page text...");
+                    try {
+                      const numPages = e?.doc?.numPages || 0;
+                      const textSections: Array<{ title: string; pageIndex: number }> = [];
+                      const seen = new Set<string>();
+                      const maxPages = Math.min(numPages, 30);
+                      
+                      const pushSection = (rawTitle: string, pageIdx: number) => {
+                        const title = String(rawTitle || '').replace(/\s+/g, ' ').trim();
+                        if (!title) return;
+                        const key = `${pageIdx}:${title.toLowerCase()}`;
+                        if (seen.has(key)) return;
+                        seen.add(key);
+                        textSections.push({ title, pageIndex: pageIdx });
+                      };
+                      
+                      for (let i = 0; i < maxPages; i++) {
+                        try {
+                          const page = await (e as any).doc.getPage(i + 1);
+                          const textContent = await page.getTextContent();
+                          const items = (textContent.items || []) as any[];
+                          
+                          // Group by visual line using Y coordinate (transform[5]) and keep an estimated font size per line
+                          const linesMap = new Map<number, { y: number; parts: string[]; maxSize: number }>();
+                          const allSizes: number[] = [];
+                          for (const it of items) {
+                            const str = String(it?.str || '').trim();
+                            if (!str) continue;
+                            const y = Math.round(Number(it?.transform?.[5] ?? 0));
+                            const a = Number(it?.transform?.[0] ?? 0);
+                            const d = Number(it?.transform?.[3] ?? 0);
+                            const estSize = Math.max(0, Math.sqrt(a * a + d * d));
+                            allSizes.push(estSize);
+                            if (!linesMap.has(y)) linesMap.set(y, { y, parts: [], maxSize: 0 });
+                            const rec = linesMap.get(y) as any;
+                            rec.parts.push(str);
+                            if (estSize > rec.maxSize) rec.maxSize = estSize;
+                          }
+                          const median = (() => {
+                            if (allSizes.length === 0) return 0;
+                            const s = allSizes.slice().sort((x, y) => x - y);
+                            const mid = Math.floor(s.length / 2);
+                            return s.length % 2 ? s[mid] : (s[mid - 1] + s[mid]) / 2;
+                          })();
+                          
+                          const lines = Array.from(linesMap.values())
+                            .sort((a, b) => b.y - a.y)
+                            .map((l) => ({ text: l.parts.join(' ').replace(/\s+/g, ' ').trim(), size: l.maxSize }))
+                            .filter((l) => !!l.text);
+                          
+                          // Heuristics for headings
+                          const isTitleCase = (s: string) => {
+                            // at least two words start with capital and not ALL CAPS paragraphs
+                            const words = s.split(/\s+/);
+                            const capsStart = words.filter((w) => /^[A-Z][A-Za-z0-9\-]*$/.test(w)).length;
+                            return capsStart >= Math.min(2, Math.ceil(words.length * 0.5));
+                          };
+                          const isAllCapsShort = (s: string) => /^(?:[A-Z0-9][A-Z0-9\-]*\s*){1,8}$/.test(s);
+                          const wordCount = (s: string) => s.split(/\s+/).filter(Boolean).length;
+                          const numOnly = /^\d+(?:\.\d+)*$/;
+                          const numWithTitle = /^\d+(?:\.\d+)*\s+.+/;
+                          const namedSections = /^(Abstract|Introduction|Background|Related\s+Work|Methods?|Approach|Experiments?|Results|Discussion|Conclusions?|References|Appendix|Baselines?)\b/i;
+                          const tableFigure = /^(Table|Figure)\s+\d+[A-Za-z]?\b/i;
+                          
+                          for (let li = 0; li < lines.length; li++) {
+                            const { text: line, size } = lines[li];
+                            if (!line) continue;
+                            
+                            // 1) Number-only heading: try to merge with nearby title line (next or previous)
+                            if (numOnly.test(line)) {
+                              const next = lines[li + 1]?.text || '';
+                              const prev = lines[li - 1]?.text || '';
+                              const candidate = isTitleCase(next) ? next : (isTitleCase(prev) ? prev : '');
+                              if (candidate) {
+                                pushSection(`${line} ${candidate}`, i);
+                              } else {
+                                pushSection(line, i);
+                              }
+                              continue;
+                            }
+                            
+                            // 2) Number with title on same line
+                            if (numWithTitle.test(line)) {
+                              pushSection(line, i);
+                              continue;
+                            }
+                            
+                            // 3) Canonical named sections
+                            if (namedSections.test(line)) {
+                              pushSection(line, i);
+                              continue;
+                            }
+                            
+                            // 4) Table/Figure labels
+                            if (tableFigure.test(line)) {
+                              pushSection(line, i);
+                              continue;
+                            }
+                            
+                            // 5) Font-size based heading heuristic
+                            const wc = wordCount(line);
+                            const looksHeading = (size > median * 1.15) && wc > 0 && wc <= 12 && (isTitleCase(line) || isAllCapsShort(line));
+                            if (looksHeading) {
+                              pushSection(line, i);
+                              continue;
+                            }
+                          }
+                        } catch (err) {
+                          console.log(`🔍 PDF: Failed to extract text from page ${i + 1}:`, err);
+                        }
+                      }
+                      
+                      if (textSections.length > 0) {
+                        console.log("🔍 PDF: Found sections from text extraction:", textSections);
+                        (window as any).__pdfOutline = textSections;
+                        window.dispatchEvent(new CustomEvent('pdf-outline', { detail: { sections: textSections } }));
+                      }
+                    } catch (err) {
+                      console.log("🔍 PDF: Text-based section extraction failed:", err);
+                    }
+                  }
+                } catch (err) {
+                  console.log("🔍 PDF: Outline extraction completely failed:", err);
+                }
+              })();
               if (pendingNavRef.current !== null) {
-                jumpToIndex(pendingNavRef.current);
+                try {
+                  pageNavigationPluginInstance.jumpToPage(pendingNavRef.current);
+                } catch {}
+                scrollToPageIndex(pendingNavRef.current ?? 0);
                 pendingNavRef.current = null;
               }
-            } catch {}
-          }}
-          onPageChange={(e) => onPageChange?.(e.currentPage + 1)}
-        />
+              // Apply any globally-persisted pending nav
+              const globalPending = (window as any).__pendingPdfNav;
+              if (typeof globalPending === 'number') {
+                try { pageNavigationPluginInstance.jumpToPage(globalPending); } catch {}
+                scrollToPageIndex(globalPending ?? 0);
+                (window as any).__pendingPdfNav = null;
+              }
+            }}
+            onPageChange={(e) => {
+              if (onPageChange) {
+                onPageChange(e.currentPage + 1); // Convert back to 1-based
+              }
+            }}
+          />
+        </div>
       </Worker>
     </div>
   );
 };
 
-export default PDFViewer;
\ No newline at end of file
+export default PDFViewer;
diff --git a/src/components/ui/Button.tsx b/src/components/ui/Button.tsx
index b7bdd73..f085a5d 100644
--- a/src/components/ui/Button.tsx
+++ b/src/components/ui/Button.tsx
@@ -9,7 +9,7 @@ const buttonVariants = cva(
   {
     variants: {
       variant: {
-        default: "bg-[var(--brand)] text-white hover:brightness-105",
+        default: "bg-primary text-primary-foreground hover:bg-primary/90",
         destructive:
           "bg-destructive text-destructive-foreground hover:bg-destructive/90",
         outline:
diff --git a/src/hooks/useRealtimeSession.ts b/src/hooks/useRealtimeSession.ts
index b78a62f..67ebda4 100644
--- a/src/hooks/useRealtimeSession.ts
+++ b/src/hooks/useRealtimeSession.ts
@@ -195,35 +195,6 @@ export function useRealtimeSession(callbacks: RealtimeSessionCallbacks = {}) {
         console.log("🎵 Audio response received:", event);
         // On first audio, set up auto-advance plan based on latest search results
         setupAutoAdvanceForSpeech();
-        // Start fine-grained match navigation synced to speech time
-        try {
-          if (typeof window !== 'undefined') {
-            const state: any = (window as any).__pdfSearchState;
-            const results = Array.isArray(state?.results) ? state.results : [];
-            const totalMatches = results.length;
-            if (totalMatches > 0) {
-              const token = `match-sync-${Date.now()}-${Math.random().toString(36).slice(2)}`;
-              const start = Date.now();
-              const durationMs = (window as any).__pdfSpeechMs ?? 9000; // configurable
-              let lastIdx = -1;
-              (window as any).__matchSyncToken = token;
-              const tick = () => {
-                if ((window as any).__matchSyncToken !== token) return;
-                const elapsed = Date.now() - start;
-                const frac = Math.max(0, Math.min(1, elapsed / durationMs));
-                const idx = Math.min(totalMatches - 1, Math.floor(frac * totalMatches));
-                if (idx !== lastIdx) {
-                  lastIdx = idx;
-                  try {
-                    window.dispatchEvent(new CustomEvent('pdf-jump-to', { detail: { index: idx } }));
-                  } catch {}
-                }
-                if (frac < 1) (window as any).__matchSyncTimer = setTimeout(tick, 450);
-              };
-              (window as any).__matchSyncTimer = setTimeout(tick, 300);
-            }
-          }
-        } catch {}
         break;
       }
       case "response.audio.done": {
@@ -240,11 +211,6 @@ export function useRealtimeSession(callbacks: RealtimeSessionCallbacks = {}) {
         (window as any).__speechAdvanceToken = undefined;
         (window as any).__speechAdvanceTimers?.forEach((id: number) => clearTimeout(id));
         (window as any).__speechAdvanceTimers = [];
-        try {
-          if ((window as any).__matchSyncTimer) clearTimeout((window as any).__matchSyncTimer);
-          (window as any).__matchSyncToken = undefined;
-          (window as any).__matchSyncTimer = undefined;
-        } catch {}
         break;
       }
       default: {
@@ -397,21 +363,7 @@ export function useRealtimeSession(callbacks: RealtimeSessionCallbacks = {}) {
   }, []);
 
   const sendEvent = useCallback((ev: any) => {
-    if (!sessionRef.current) {
-      console.warn('sendEvent: session not connected; event ignored', ev);
-      return false;
-    }
-    if (!ev || typeof ev !== 'object' || typeof ev.type !== 'string') {
-      console.warn('sendEvent: invalid event payload; expected { type: string, ... }', ev);
-      return false;
-    }
-    try {
-      sessionRef.current.transport.sendEvent(ev);
-      return true;
-    } catch (error) {
-      console.error('sendEvent: failed to send event', error, ev);
-      return false;
-    }
+    sessionRef.current?.transport.sendEvent(ev);
   }, []);
 
   const mute = useCallback((m: boolean) => {
diff --git a/src/lib/agents/tutorAgent.ts b/src/lib/agents/tutorAgent.ts
index d5e40cc..61ff39a 100644
--- a/src/lib/agents/tutorAgent.ts
+++ b/src/lib/agents/tutorAgent.ts
@@ -1,245 +1,862 @@
-import { RealtimeAgent, tool } from '@openai/agents/realtime'
+import { RealtimeAgent, tool } from '@openai/agents/realtime';
 
-/**
- * Create the Tutor Agent configured for this app.
- * - Uses semantic_highlight to find and highlight relevant passages
- * - Uses search_document and navigate to keep the PDF in view with the answer
- */
 export const createTutorAgent = (pdfTitle: string, pdfContent: string): RealtimeAgent => {
+  console.log("🤖 Creating TutorAgent with:", { pdfTitle, pdfContentLength: pdfContent.length });
+  console.log("🤖 TutorAgent will introduce itself as AI tutor for:", pdfTitle);
+  
   return new RealtimeAgent({
     name: 'ai_tutor',
-    instructions: `You are an AI Tutor helping a student understand a PDF titled "${pdfTitle}".
-Follow these rules strictly:
-0) On your first response after session start, begin with exactly:
-   "Hello! I'm your AI tutor. I'm here to help you understand this document, ${pdfTitle}. What would you like to know?"
-1) Always ground answers ONLY in the provided PDF content. Avoid external knowledge.
-2) Always reference page numbers explicitly, and quote short phrases when useful.
-3) Before answering, call semantic_highlight with the student's question (or your draft answer) to highlight relevant text in the PDF.
-4) If needed, call search_document to locate exact phrases, then call navigate to jump to the first relevant occurrence.
-5) Keep responses concise and supportive; ask brief follow-ups when helpful.
-6) Use assertive, non-hedging language grounded by citations. Do not use words like "likely", "appears", "probably", or filler like "in this document". State facts directly and cite the page/section.
-`,
-    tools: [
-      // Get page count
-      tool({
-        name: 'get_page_count',
-        description: 'Return the total number of pages in the currently open PDF',
-        parameters: { type: 'object', properties: {}, required: [], additionalProperties: false },
-        execute: async () => {
-          try {
-            let numPages: number | undefined = undefined
-            if (typeof window !== 'undefined') {
-              numPages = (window as any).__pdfNumPages
-              if (numPages === undefined) {
-                const wait = new Promise<number>((resolve) => {
-                  const h = (ev: any) => {
-                    window.removeEventListener('pdf-doc-loaded', h as EventListener)
-                    resolve(ev?.detail?.numPages ?? 0)
-                  }
-                  window.addEventListener('pdf-doc-loaded', h as EventListener, { once: true })
-                })
-                numPages = await wait
-              }
-            }
-            return { success: true, pages: numPages ?? 0 }
-          } catch (e) {
-            return { success: false, pages: 0 }
-          }
-        },
-      }),
+    instructions: `You are an AI tutor helping a student understand a PDF document titled "${pdfTitle}".
+
+CRITICAL: You MUST respond in ENGLISH ONLY. Never use Spanish or any other language.
+
+CRITICAL INTRODUCTION REQUIREMENT: You MUST introduce yourself immediately when the session starts or when you receive a response.create event. Always begin with: "Hello! I'm your AI tutor. I'm here to help you understand this document, ${pdfTitle}. What would you like to know?"
+
+After your introduction, wait for user questions. If you haven't introduced yourself yet in this session, you MUST do so before answering any questions. 
+
+You are now a HIGHLY INTERACTIVE tutor that automatically highlights and navigates to relevant content as you speak. You MUST:
+
+1. **AUTOMATIC SECTION HIGHLIGHTING**: When you mention ANY section name, table, figure, or concept from the document, IMMEDIATELY highlight it using Sument or navigate_to_section.
+
+2. **CONTEXTUAL UI AWARENESS**: As you speak about specific content, continuously highlight the relevant text, tables, figures, or sections you're referencing.
+
+3. **SMART CONTENT DETECTION**: If you mention "baselines", "Table 1", "Figure 2", "Section 5.1", etc., automatically find and highlight that content.
+
+4. **CITATION DETECTION**: If you encounter citations (like "[1]", "[Smith et al., 2023]", or reference numbers), automatically use research_citation to look up the reference.
+
+5. **SPEECH-SYNCHRONIZED HIGHLIGHTING**: The system now automatically detects and highlights content as you speak:
+   - When you say "Table 1" → automatically circles Table 1
+   - When you say "Figure 2" → automatically circles Figure 2  
+   - When you say "[1]" or "[Smith et al., 2023]" → automatically researches citation
+   - When you quote text in "quotes" → automatically highlights that text
+   - You can still manually call tools, but speech detection provides automatic highlighting
+
+6. **SECTION DETECTION**: For section-related questions, use highlight_section_content to find and highlight entire sections, but time it with your speech flow.
+
+Citation and Highlighting Strategy:
+- FIRST: Use search_document to find relevant content and get context
+- THEN: Begin your spoken response with page references
+- DURING your speech: Use highlight_quote to highlight specific text you're quoting
+- AS you mention tables/figures: Use circle_table/circle_figure appropriately
+- Always refer to the document explicitly (say the page number)
+- Quote short phrases from the PDF that support your statements
+
+Your capabilities:
+1. Answer questions about the document content
+2. Provide explanations and clarifications  
+3. Navigate to specific pages when referencing content
+4. Highlight important text synchronized with your speech
+5. Engage in natural voice conversation
+6. **Time highlights to match your verbal references**
+
+Document content:
+${pdfContent}
+
+ENHANCED MULTI-ANNOTATION SYSTEM: You can now make multiple annotations in a single response when necessary:
+
+CORRECTED WORKFLOW: When the user asks about ANY topic:
+
+1. **CONTENT DISCOVERY ONLY**: Use search_document to find relevant content for your response
+   - This is ONLY for gathering information to answer the question
+   - Do NOT use this to highlight the user's query terms
+   - Use this to find what you'll talk about in your response
+
+2. **RESPONSE PHASE**: Speak naturally about the content you found
+   - Reference specific pages, quotes, tables, figures as you explain
+   - The speech-synchronized system will automatically annotate what you mention
+
+3. **NO IMMEDIATE ANNOTATIONS**: Do NOT call annotation tools based on the user's question
+   - If user asks "tell me about data" → Do NOT annotate "data"
+   - Instead, find relevant data content, then speak about it
+   - Let the speech system annotate the specific content you reference
+
+4. **SPEECH-DRIVEN ANNOTATIONS**: The system automatically annotates as you speak:
+   - When you say "Table 1 shows..." → Table 1 gets circled
+   - When you quote text → That text gets highlighted  
+   - When you mention "[1]" → Citation gets researched
+   - All based on YOUR speech content, not the user's query
+
+MULTI-CITATION SUPPORT: When discussing multiple citations, call research_citation for each one mentioned.
+
+CORRECT EXAMPLE: User asks "tell me about the data"
+
+**WRONG APPROACH** (what it was doing):
+- Immediately annotate "data" from user query ❌
+- Highlight random occurrences of "data" ❌
+
+**CORRECT APPROACH** (what it should do):
+1. Use search_document("data") to find relevant content ✅
+2. Speak naturally: "The data is presented in Table 1 on page 5, which shows performance metrics. As you can see from the results, the MH-SSM model achieves 1.80 WER as reported in Smith et al. 2023..."
+3. **Speech system automatically**:
+   - Circles "Table 1" when you say it ✅
+   - Highlights specific quotes when you quote them ✅  
+   - Researches "Smith et al. 2023" when you mention it ✅
+
+SPEECH-DRIVEN ANNOTATION: Only annotate what YOU reference in your response, not what the user asked about.
+
+REMOVED: All automatic annotation instructions. The agent should focus on providing helpful explanations.
+
+SIMPLE WORKFLOW:
+1. Use search_document to find relevant content
+2. Respond with specific page references and quotes
+3. Use highlight_quote to highlight the EXACT text you're citing in your response
+4. Always reference the PDF content you found
+
+Navigation commands:
+- If the user says anything like "go to page N", "page N", or "open page N", IMMEDIATELY call navigate_to_page with that page number.
+- Accept both digits and number words (e.g., "eight" → 8).
+
+When you want to navigate to a specific page, use the navigate_to_page tool.
+
+When you want to highlight a phrase, prefer search_document so the actual words are highlighted. Only use create_annotation for explicit shapes upon request.
+
+Guidelines:
+- Be encouraging and supportive
+- Explain concepts clearly and at an appropriate level
+- Ask follow-up questions to ensure understanding
+- Use analogies and examples when helpful
+- Be conversational and natural in your responses
+- Always be accurate and cite the document when making claims
+- ALWAYS respond with voice output - never be silent
+- **CONTINUOUSLY highlight relevant content as you speak about it**
+- **ALWAYS check for sections first using highlight_section_content**
 
-      // Search within the document using the viewer's search plugin
+Remember: You're having a voice conversation, so keep responses natural and spoken-friendly rather than overly formal or written-style. You are now a VISUAL tutor that makes the document come alive with real-time highlighting. ALWAYS check if the user is asking about a section first! If unsure, call list_sections to see available sections, then navigate_to_section.`,
+    
+    tools: [
       tool({
         name: 'search_document',
-        description: 'Search for a term or phrase in the PDF and return matches with excerpts',
+        description: 'Search for specific terms or concepts in the PDF document',
         parameters: {
           type: 'object',
-          properties: { query: { type: 'string', description: 'Term or phrase to search' } },
+          properties: {
+            query: {
+              type: 'string',
+              description: 'The term or concept to search for'
+            }
+          },
           required: ['query'],
-          additionalProperties: false,
+          additionalProperties: false
         },
         execute: async (input: any) => {
-          const q = String(input?.query || '').trim()
-          if (!q) return { success: false, message: 'Empty query', matches: [] }
-          if (typeof window === 'undefined') return { success: false, message: 'No window', matches: [] }
-
-          const requestId = `srch-${Date.now()}-${Math.random().toString(36).slice(2)}`
-          const wait = new Promise<void>((resolve) => {
-            const handler = (ev: any) => {
-              if (ev?.detail?.requestId === requestId) {
-                window.removeEventListener('pdf-search-results', handler as EventListener)
-                resolve()
+          console.log("🔍 SEARCH TOOL CALLED:", input);
+          console.log("🔍 Window object available:", typeof window !== 'undefined');
+          const { query } = input;
+          
+          // Request the viewer to perform search and return matches
+          const requestId = `req-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+          let results: Array<{ page: number; pageIndex: number; matchIndex: number; startIndex: number; endIndex: number; excerpt: string }>
+            = [];
+
+          if (typeof window !== 'undefined') {
+            // Clear previous search marks when asking new questions
+            // Note: Circles are preserved unless it's a completely new topic
+            window.dispatchEvent(new CustomEvent('pdf-clear-highlights'));
+            console.log("🔍 Cleared previous highlights for new search (keeping circles)");
+            const waitForResults = new Promise<void>((resolve) => {
+              const handler = (event: any) => {
+                if (event?.detail?.requestId === requestId) {
+                  results = event.detail.results || [];
+                  window.removeEventListener('pdf-search-results', handler as EventListener);
+                  resolve();
+                }
+              };
+              window.addEventListener('pdf-search-results', handler as EventListener, { once: true });
+            });
+
+            // Build robust keyword variants prioritizing longer phrases to reduce character fragmentation
+            const q = String(query || '').trim();
+            const base = q.toLowerCase();
+            const variants = new Set<string>();
+            
+            // Prioritize the original query first (longer phrases highlight better)
+            variants.add(base);
+            
+            // Only add variations if the original is short (to avoid over-fragmentation)
+            if (base.length <= 15) {
+              // Handle hyphenated terms
+              if (base.includes('-')) {
+                variants.add(base.replace(/-/g, ''));
+                variants.add(base.replace(/-/g, ' '));
+              } else {
+                // also add hyphenated
+                variants.add(base.replace(/\s+/g, '-'));
+              }
+            }
+            
+            // Handle mathematical expressions and equations
+            if (/^[a-z]\d*$/i.test(base)) {
+              // Single variables like x, y, h1, etc.
+              variants.add(base.toUpperCase());
+              variants.add(base.toLowerCase());
+            }
+            
+            // Handle common mathematical terms
+            if (base.includes('equation') || base.includes('formula')) {
+              variants.add('equation');
+              variants.add('formula');
+              variants.add('expression');
+            }
+            
+            // Handle subscripts and superscripts (common in equations)
+            if (base.match(/[a-z]\d+/i)) {
+              const letter = base.match(/[a-z]+/i)?.[0] || '';
+              const number = base.match(/\d+/)?.[0] || '';
+              if (letter && number) {
+                variants.add(letter); // Just the letter part
+                variants.add(`${letter}_${number}`); // Underscore notation
+                variants.add(`${letter}${number}`); // Original
+              }
+            }
+            
+            // Domain-specific expansions
+            if (/^mh\s*-?\s*ssm[s]?$/i.test(base) || /multi\s*head\s*state\s*space\s*model/i.test(base)) {
+              ['mh-ssm','mhssm','mh ssm','multi-head state space model','multi head state space model','multihead state space model'].forEach(v=>variants.add(v));
+            }
+            if (/^ssm[s]?$/i.test(base) || /state\s*space\s*model/i.test(base)) {
+              ['ssm','ssms','state space model','state space models'].forEach(v=>variants.add(v));
+            }
+            // Create keyword objects for better phrase matching
+            const keywordObjects = Array.from(variants).map((v) => ({ 
+              keyword: v, 
+              matchCase: false
+            }));
+
+            console.log("🔍 Dispatching pdf-search-request event:", { requestId, keywordObjects });
+            window.dispatchEvent(new CustomEvent('pdf-search-request', {
+              detail: { requestId, keywords: keywordObjects }
+            }));
+            console.log("🔍 Event dispatched successfully");
+
+            await waitForResults;
+
+            // AUTOMATIC SECTION DETECTION: If this looks like a section title, highlight the entire section
+            if (typeof window !== 'undefined' && (window as any).__pdfOutline) {
+              const outline: Array<{ title: string; pageIndex: number }> = (window as any).__pdfOutline || [];
+              const searchTerm = query.toLowerCase().trim();
+              
+              // Check if this query matches a section title
+              const sectionMatch = outline.find(s => 
+                s.title.toLowerCase().includes(searchTerm) ||
+                searchTerm.includes(s.title.toLowerCase()) ||
+                s.title.toLowerCase() === searchTerm
+              );
+              
+              if (sectionMatch) {
+                console.log(`🎯 AUTO-DETECTED SECTION: "${sectionMatch.title}" on page ${sectionMatch.pageIndex + 1}`);
+                // Navigate to the section
+                try {
+                  if ((window as any).pdfJumpToPage) {
+                    (window as any).pdfJumpToPage(sectionMatch.pageIndex + 1);
+                  } else {
+                    window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: sectionMatch.pageIndex } }));
+                  }
+                } catch {}
+                
+                // Highlight the entire section by searching for the section title text
+                const sectionRequestId = `section-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+                window.dispatchEvent(new CustomEvent('pdf-search-request', {
+                  detail: { requestId: sectionRequestId, keywords: [{ keyword: sectionMatch.title, matchCase: false }] }
+                }));
               }
             }
-            window.addEventListener('pdf-search-results', handler as EventListener)
-          })
 
-          // Build simple keyword list (viewer performs actual search)
-          const keywords = [{ keyword: q, matchCase: false }]
-          window.dispatchEvent(new CustomEvent('pdf-search-request', { detail: { requestId, keywords } }))
-          await wait
+            // Build per-page first-match steps across ALL relevant pages
+            const pageToFirst = new Map<number, { pageIndex: number; matchIndex: number; globalIndex: number }>();
+            for (let i = 0; i < results.length; i++) {
+              const r: any = results[i];
+              const gi = typeof r.globalIndex === 'number' ? r.globalIndex : i;
+              if (!pageToFirst.has(r.pageIndex) || gi < (pageToFirst.get(r.pageIndex) as any).globalIndex) {
+                pageToFirst.set(r.pageIndex, { pageIndex: r.pageIndex, matchIndex: r.matchIndex, globalIndex: gi });
+              }
+            }
+            const steps = Array.from(pageToFirst.values()).sort((a, b) => a.globalIndex - b.globalIndex);
+
+            // Expose full search state for UI/agent summarization
+            (window as any).__pdfSearchState = {
+              query,
+              results,
+              steps,
+              currentIndex: 0,
+              lastJumpMs: 0,
+            };
+            window.dispatchEvent(new CustomEvent('pdf-search-state', { detail: { query, results, steps } }));
+
+            // Jump to first relevant page
+            if (steps.length > 0) {
+              try {
+                const first = steps[0];
+                if ((window as any).pdfJumpToPage) (window as any).pdfJumpToPage(first.pageIndex + 1);
+                else window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: first.pageIndex } }));
+              } catch {}
 
-          const state: any = (window as any).__pdfSearchState
-          const results = Array.isArray(state?.results) ? state.results : []
-          const pagesSet = new Set<number>()
-          const citations: Array<{ page: number; quote: string }> = []
+              // Stay on the first relevant page instead of auto-advancing
+              // Auto-advance is disabled to keep focus on the current reference
+            }
+          }
+
+          // Aggregate for summarization and multi-citation
+          const pagesSet = new Set<number>();
+          const citations: Array<{ page: number; quote: string }> = [];
           for (const r of results) {
-            pagesSet.add(r.page)
-            const quote = (r.excerpt || '').slice(0, 160)
-            if (quote) citations.push({ page: r.page, quote })
+            pagesSet.add(r.page);
+            const quote = (r.excerpt || '').slice(0, 140);
+            if (quote) citations.push({ page: r.page, quote });
           }
-          const pages = Array.from(pagesSet).sort((a, b) => a - b)
+          const pages = Array.from(pagesSet).sort((a, b) => a - b);
+
           return {
             success: true,
-            query: q,
+            query,
             matches: results,
             pages,
             citations: citations.slice(0, 12),
-          }
-        },
+            message: results.length > 0
+              ? `Found ${results.length} matches for "${query}" across pages ${pages.join(', ')}.`
+              : `No matches found for "${query}".`
+          };
+        }
       }),
 
-      // Highlight arbitrary text via the viewer's highlight plugin
       tool({
-        name: 'highlight_text',
-        description: 'Programmatically highlight one or more phrases in the PDF viewer',
+        name: 'highlight_section_content',
+        description: 'Detect if a term is a section title and highlight the ENTIRE section content using multiple relevant keywords to capture most of the section text',
         parameters: {
           type: 'object',
           properties: {
-            texts: { type: 'array', items: { type: 'string' } },
-            matchCase: { type: 'boolean' },
+            term: {
+              type: 'string',
+              description: 'The term to check if it\'s a section title and highlight'
+            }
           },
-          required: ['texts'],
-          additionalProperties: false,
+          required: ['term'],
+          additionalProperties: false
         },
         execute: async (input: any) => {
-          try {
-            if (typeof window === 'undefined') return { success: false }
-            const texts: string[] = Array.isArray(input?.texts) ? input.texts.filter(Boolean) : []
-            const matchCase = Boolean(input?.matchCase)
-            if (!texts.length) return { success: false }
-            const api = (window as any).pdfHighlighter
-            if (!api?.highlightSnippets && !api?.highlightText) return { success: false }
-            if (api.highlightSnippets) await api.highlightSnippets(texts, { matchCase })
-            else await api.highlightText(texts, { matchCase })
-            return { success: true, count: texts.length }
-          } catch {
-            return { success: false }
+          console.log("🎯 SECTION CONTENT HIGHLIGHT TOOL CALLED:", input);
+          const { term } = input;
+          
+          if (typeof window !== 'undefined' && (window as any).__pdfOutline) {
+            const outline: Array<{ title: string; pageIndex: number }> = (window as any).__pdfOutline || [];
+            const searchTerm = term.toLowerCase().trim();
+            
+            // Find exact or partial section matches with flexible matching
+            const sectionMatch = outline.find(s => {
+              const sectionTitle = s.title.toLowerCase().trim();
+              const userTerm = searchTerm.toLowerCase().trim();
+              
+              // Exact match
+              if (sectionTitle === userTerm) return true;
+              
+              // Bidirectional contains
+              if (sectionTitle.includes(userTerm) || userTerm.includes(sectionTitle)) return true;
+              
+              // Handle common variations
+              const variations = {
+                'conclusion': ['conclusions', 'concluding', 'summary'],
+                'intro': ['introduction', 'introductory'],
+                'method': ['methods', 'methodology'],
+                'result': ['results'],
+                'experiment': ['experiments', 'experimental'],
+                'discussion': ['discussions'],
+                'reference': ['references', 'bibliography'],
+                'appendix': ['appendices']
+              };
+              
+              // Check if user term matches any variation
+              for (const [key, values] of Object.entries(variations)) {
+                if (userTerm === key && values.some(v => sectionTitle.includes(v))) return true;
+                if (values.includes(userTerm) && sectionTitle.includes(key)) return true;
+              }
+              
+              return false;
+            });
+            
+             if (sectionMatch) {
+                console.log(`🎯 HIGHLIGHTING ENTIRE SECTION: "${sectionMatch.title}" on page ${sectionMatch.pageIndex + 1}`);
+                
+                // Navigate to the section page
+                try {
+                  if ((window as any).pdfJumpToPage) {
+                    (window as any).pdfJumpToPage(sectionMatch.pageIndex + 1);
+                  } else {
+                    window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: sectionMatch.pageIndex } }));
+                  }
+                } catch {}
+                
+                // Highlight the entire section content using multiple relevant terms
+                const sectionRequestId = `section-content-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+                
+                // Extract multiple key terms from the section title and create comprehensive search
+                const titleWords = sectionMatch.title.toLowerCase().split(/\s+/).filter(word => 
+                  word.length > 2 && !['the', 'and', 'for', 'with', 'this', 'that', 'from', 'are', 'was', 'were', 'been', 'have', 'has', 'had'].includes(word)
+                );
+                
+                // Strategy: Instead of highlighting keywords, find and highlight actual sentences in the section
+                // Use a broader search that captures section content, not just title words
+                
+                const searchTerms = [];
+                
+                // Only use specific, meaningful terms - NO common words
+                searchTerms.push({ keyword: term.toLowerCase(), matchCase: false });
+                
+                // Add only the section title itself for title highlighting
+                searchTerms.push({ keyword: sectionMatch.title, matchCase: false });
+                
+                console.log(`🎯 Highlighting section content with common words:`, searchTerms);
+                
+                window.dispatchEvent(new CustomEvent('pdf-search-request', {
+                  detail: { requestId: sectionRequestId, keywords: searchTerms }
+                }));
+
+                return {
+                  success: true,
+                  section: term,
+                  page: sectionMatch.pageIndex + 1,
+                  message: `Highlighted section content for "${term}" on page ${sectionMatch.pageIndex + 1} using key term "${titleWords[0] || term}"`
+                };
+              } else {
+              return {
+                success: false,
+                term,
+                message: `No section found matching "${term}". Try searching for the content instead.`
+              };
+            }
           }
-        },
+          
+          return {
+            success: false,
+            term,
+            message: "PDF outline not available. Cannot detect sections."
+          };
+        }
       }),
 
-      // Semantic highlight: call server similarity API, then highlight snippets in viewer
       tool({
-        name: 'semantic_highlight',
-        description: 'Highlight semantically similar snippets from the PDF given a query or answer',
+        name: 'circle_table',
+        description: 'Circle a table label by searching for its caption (e.g., "Table 1") and drawing a circle overlay around it',
         parameters: {
           type: 'object',
           properties: {
-            text: { type: 'string', description: 'Query or draft answer to ground' },
-            topK: { type: 'number', description: 'Number of snippets to highlight (default 5)' },
+            label: { type: 'string', description: 'The table label to circle, e.g., "Table 1"' }
           },
-          required: ['text'],
-          additionalProperties: false,
+          required: ['label'],
+          additionalProperties: false
         },
         execute: async (input: any) => {
-          try {
-            if (typeof window === 'undefined') return { success: false }
-            const text = String(input?.text || '').trim()
-            const topK = Math.max(1, Math.min(10, Number(input?.topK ?? 5)))
-            if (!text) return { success: false }
-            const docId = (window as any).__currentDocumentId
-            if (!docId) return { success: false, message: 'No current document id' }
-            const res = await fetch(`/api/documents/${docId}/similarity`, {
-              method: 'POST',
-              headers: { 'Content-Type': 'application/json' },
-              body: JSON.stringify({ text, topK }),
-            })
-            if (!res.ok) return { success: false, status: res.status }
-            const data = await res.json()
-            const snippets: string[] = Array.isArray(data?.snippets)
-              ? data.snippets.map((s: any) => String(s?.snippet || '').trim()).filter(Boolean)
-              : []
-            if (snippets.length === 0) return { success: true, count: 0 }
-            const api = (window as any).pdfHighlighter
-            if (api?.highlightSnippets) await api.highlightSnippets(snippets)
-            else if (api?.highlightText) await api.highlightText(snippets)
-            return { success: true, count: snippets.length }
-          } catch (e) {
-            return { success: false }
+          const label = String(input?.label || '').trim();
+          if (!label) {
+            return { success: false, message: 'Missing table label' };
           }
-        },
+          if (typeof window !== 'undefined') {
+            // Add delay to sync with speech timing
+            setTimeout(() => {
+              window.dispatchEvent(new CustomEvent('tutor-circle-table', { detail: { label } }));
+            }, 300); // 300ms delay for table references
+            return { success: true, label, message: `Will circle ${label} in 300ms` };
+          }
+          return { success: false, label, message: 'Not in browser context' };
+        }
       }),
 
-      // Navigate to a page or a specific search match index
       tool({
-        name: 'navigate',
-        description: 'Navigate to a page, or jump to a specific search match index',
+        name: 'circle_figure',
+        description: 'Circle a figure label by searching for its caption (e.g., "Figure 2") and drawing a circle overlay around it',
         parameters: {
           type: 'object',
           properties: {
-            page: { type: ['number', 'string'] },
-            matchIndex: { type: 'number' },
-            reason: { type: 'string' },
+            label: { type: 'string', description: 'The figure label to circle, e.g., "Figure 2"' }
           },
-          required: [],
-          additionalProperties: false,
+          required: ['label'],
+          additionalProperties: false
         },
         execute: async (input: any) => {
-          try {
-            if (typeof window === 'undefined') return { success: false }
-            if (typeof input?.matchIndex === 'number' && input.matchIndex >= 0) {
-              window.dispatchEvent(new CustomEvent('pdf-jump-to', { detail: { index: input.matchIndex } }))
-              return { success: true, matchIndex: input.matchIndex }
-            }
-            const raw = input?.page ?? '1'
-            const toInt = (val: any): number | null => {
-              if (typeof val === 'number') return val
-              const m = String(val).match(/\d+/)
-              return m ? parseInt(m[0], 10) : null
-            }
-            const n = toInt(raw) || 1
-            if ((window as any).pdfJumpToPage) (window as any).pdfJumpToPage(n)
-            else window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: Math.max(0, n - 1) } }))
-            return { success: true, page: n }
-          } catch {
-            return { success: false }
+          const label = String(input?.label || '').trim();
+          if (!label) return { success: false, message: 'Missing figure label' };
+          if (typeof window !== 'undefined') {
+            // Add delay to sync with speech timing
+            setTimeout(() => {
+              window.dispatchEvent(new CustomEvent('tutor-circle-figure', { detail: { label } }));
+            }, 300); // 300ms delay for figure references
+            return { success: true, label, message: `Will circle ${label} in 300ms` };
           }
+          return { success: false, label, message: 'Not in browser context' };
+        }
+      }),
+
+      tool({
+        name: 'research_citation',
+        description: 'Research a citation mentioned in the document by dispatching a research agent to look up the paper/reference',
+        parameters: {
+          type: 'object',
+          properties: {
+            citation: {
+              type: 'string',
+              description: 'The citation text or reference number (e.g., "[1]", "[Smith et al., 2023]", "Johnson 2022")'
+            },
+            context: {
+              type: 'string',
+              description: 'The context in which the citation was mentioned for better research'
+            }
+          },
+          required: ['citation'],
+          additionalProperties: false
         },
+        execute: async (input: any) => {
+          const { citation, context } = input;
+          console.log("📚 CITATION RESEARCH TOOL CALLED:", { citation, context });
+          
+          if (!citation || typeof citation !== 'string') {
+            return { success: false, message: 'Invalid citation provided' };
+          }
+
+          if (typeof window !== 'undefined') {
+            // Dispatch event to trigger citation research
+            const researchRequestId = `citation-research-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+            
+            console.log("📚 Dispatching citation research request:", { citation, context, researchRequestId });
+            
+            window.dispatchEvent(new CustomEvent('tutor-citation-research', {
+              detail: { 
+                citation: citation.trim(),
+                context: context || '',
+                requestId: researchRequestId
+              }
+            }));
+            
+            return {
+              success: true,
+              citation,
+              message: `Researching citation: ${citation}`
+            };
+          }
+          
+          return { success: false, message: 'Citation research not available in current context' };
+        }
       }),
 
-      // Navigate to a section using outline if available
       tool({
         name: 'navigate_to_section',
-        description: 'Navigate to a section (by title) using the PDF outline if available',
+        description: 'Navigate to a specific section in the PDF document',
         parameters: {
           type: 'object',
-          properties: { section: { type: 'string' } },
+          properties: {
+            section: {
+              type: 'string',
+              description: 'The section title to navigate to (partial match is fine)'
+            }
+          },
           required: ['section'],
-          additionalProperties: false,
+          additionalProperties: false
         },
         execute: async (input: any) => {
+          console.log("📖 SECTION NAVIGATE TOOL CALLED:", input);
+          const { section } = input;
+          let targetPage = 1;
+
+          if (typeof window !== 'undefined') {
+            const outline: Array<{ title: string; pageIndex: number }> = (window as any).__pdfOutline || [];
+            if (outline.length > 0) {
+              const searchTerm = section.toLowerCase().trim();
+              // Try exact match first, then partial matches
+              let match = outline.find(s => 
+                s.title.toLowerCase() === searchTerm ||
+                s.title.toLowerCase().includes(searchTerm) || 
+                searchTerm.includes(s.title.toLowerCase())
+              );
+              
+              // If no match, try to find numbered sections (e.g., "5.1" should find "5" or "5.1")
+              if (!match && /\d/.test(searchTerm)) {
+                const numMatch = searchTerm.match(/(\d+(?:\.\d+)?)/);
+                if (numMatch) {
+                  const num = numMatch[1];
+                  match = outline.find(s => 
+                    s.title.includes(num) || 
+                    s.title.match(new RegExp(`\\b${num.replace('.', '\\.')}\\b`))
+                  );
+                }
+              }
+              
+              if (match) {
+                targetPage = match.pageIndex + 1;
+                console.log(`📖 Found section "${match.title}" on page ${targetPage}`);
+              }
+            }
+          }
+
           try {
-            if (typeof window === 'undefined') return { success: false }
-            const section = String(input?.section || '').trim().toLowerCase()
-            const outline: Array<{ title: string; pageIndex: number }> = (window as any).__pdfOutline || []
-            let targetIndex = -1
-            if (Array.isArray(outline) && outline.length) {
-              const exact = outline.findIndex((s) => s.title.toLowerCase() === section)
-              if (exact >= 0) targetIndex = exact
-              else targetIndex = outline.findIndex((s) => s.title.toLowerCase().includes(section))
-            }
-            const page = targetIndex >= 0 ? outline[targetIndex].pageIndex + 1 : 1
-            if ((window as any).pdfJumpToPage) (window as any).pdfJumpToPage(page)
-            else window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: Math.max(0, page - 1) } }))
-            return { success: true, page, section }
-          } catch {
-            return { success: false }
+            if ((window as any).pdfJumpToPage) {
+              (window as any).pdfJumpToPage(targetPage);
+            } else {
+              const zeroBased = Math.max(0, targetPage - 1);
+              window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: zeroBased } }));
+            }
+          } catch {}
+
+          return { 
+            success: true, 
+            section,
+            page: targetPage,
+            message: `Navigated to section "${section}" on page ${targetPage}` 
+          };
+        }
+      }),
+
+      tool({
+        name: 'get_page_count',
+        description: 'Return the total number of pages in the currently open PDF',
+        parameters: { type: 'object', properties: {}, required: [], additionalProperties: false },
+        execute: async () => {
+          let numPages: number | undefined;
+          if (typeof window !== 'undefined') {
+            numPages = (window as any).__pdfNumPages;
+            if (numPages === undefined) {
+              const wait = new Promise<number>((resolve) => {
+                const handler = (ev: any) => {
+                  window.removeEventListener('pdf-doc-loaded', handler as EventListener);
+                  resolve(ev?.detail?.numPages ?? 0);
+                };
+                window.addEventListener('pdf-doc-loaded', handler as EventListener, { once: true });
+              });
+              numPages = await wait;
+            }
+          }
+          return { success: true, pages: numPages ?? 0 };
+        }
+      }),
+
+      tool({
+        name: 'navigate_to_page',
+        description: 'Navigate to a specific page in the PDF document',
+        parameters: {
+          type: 'object',
+          properties: {
+            page: {
+              type: ['number', 'string'],
+              description: 'The page number to navigate to (number or a number word like "eight")'
+            },
+            reason: {
+              type: 'string',
+              description: 'Why you are navigating to this page'
+            }
+          },
+          required: ['page'],
+          additionalProperties: false
+        },
+        execute: async (input: any) => {
+          console.log("🧭 NAVIGATE TOOL CALLED:", input);
+          const { page: rawPage, reason } = input;
+
+          const numberWords: Record<string, number> = {
+            one: 1, two: 2, three: 3, four: 4, five: 5,
+            six: 6, seven: 7, eight: 8, nine: 9, ten: 10,
+            eleven: 11, twelve: 12, thirteen: 13, fourteen: 14, fifteen: 15,
+            sixteen: 16, seventeen: 17, eighteen: 18, nineteen: 19, twenty: 20,
+          };
+
+          let page = typeof rawPage === 'number' ? rawPage : parseInt(String(rawPage).replace(/[^\w\s-]/g, '').match(/\d+/)?.[0] || '', 10);
+          if (!page || isNaN(page)) {
+            const word = String(rawPage).toLowerCase().trim();
+            page = numberWords[word] ?? 1;
+          }
+
+          if (typeof window !== 'undefined') {
+            try {
+              if ((window as any).pdfJumpToPage) {
+                (window as any).pdfJumpToPage(page);
+          } else {
+                const zeroBased = Math.max(0, (page || 1) - 1);
+                window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: zeroBased } }));
+              }
+            } catch {}
           }
+          
+          return { 
+            success: true, 
+            page, 
+            reason,
+            message: `Navigated to page ${page}${reason ? `: ${reason}` : ''}` 
+          };
+        }
+      }),
+
+      tool({
+        name: 'highlight_quote',
+        description: 'Highlight an exact quote from the document that you are referencing in your response',
+        parameters: {
+          type: 'object',
+          properties: {
+            quote: {
+              type: 'string',
+              description: 'The exact text from the document to highlight (must match exactly)'
+            },
+            page: {
+              type: 'number',
+              description: 'The page number where this quote appears'
+            }
+          },
+          required: ['quote'],
+          additionalProperties: false
         },
+        execute: async (input: any) => {
+          const { quote, page } = input;
+          if (!quote || typeof quote !== 'string') {
+            return { success: false, message: 'Missing or invalid quote text' };
+          }
+          
+          if (typeof window !== 'undefined') {
+            const normalized = quote.replace(/\s+/g, ' ').trim();
+            if (normalized.length >= 8) {
+              // Add a small delay to better sync with speech timing
+              setTimeout(() => {
+                window.dispatchEvent(new CustomEvent('tutor-highlight-quote', {
+                  detail: { text: normalized, page }
+                }));
+              }, 500); // 500ms delay to sync better with speech
+              
+              return { success: true, quote: normalized, page, message: `Will highlight quote: "${normalized.substring(0, 50)}..." in 500ms` };
+            }
+          }
+          return { success: false, message: 'Quote too short or not in browser context' };
+        }
       }),
-    ],
-  })
-}
 
+      tool({
+        name: 'create_annotation',
+        description: 'Create a visual annotation on the PDF',
+        parameters: {
+          type: 'object',
+          properties: {
+            page: {
+              type: 'number',
+              description: 'The page number for the annotation'
+            },
+            x: {
+              type: 'number',
+              description: 'X coordinate as percentage (0-100)'
+            },
+            y: {
+              type: 'number',
+              description: 'Y coordinate as percentage (0-100)'
+            },
+            width: {
+              type: 'number',
+              description: 'Width as percentage (0-100)'
+            },
+            height: {
+              type: 'number',
+              description: 'Height as percentage (0-100)'
+            },
+            type: {
+              type: 'string',
+              enum: ['highlight', 'circle', 'rectangle'],
+              description: 'Type of annotation'
+            },
+            color: {
+              type: 'string',
+              description: 'Color in hex format (e.g., #ffff00)'
+            },
+            text: {
+              type: 'string',
+              description: 'Optional text description for the annotation'
+            }
+          },
+          required: ['page', 'x', 'y', 'width', 'height', 'type'],
+          additionalProperties: false
+        },
+        execute: async (input: any) => {
+          console.log("📝 ANNOTATION TOOL CALLED:", input);
+          const { page, x, y, width, height, type, color = '#ffff00', text } = input;
+          
+          const annotation = {
+            id: Date.now().toString(),
+            page,
+            x,
+            y,
+            width,
+            height,
+            type,
+            color,
+            text
+          };
+          
+          console.log("📝 Creating annotation:", annotation);
+          
+          // Dispatch custom event for UI to handle annotation creation
+          if (typeof window !== 'undefined') {
+            console.log("📝 Dispatching annotation event");
+            window.dispatchEvent(new CustomEvent('tutor-annotation-created', {
+              detail: { annotation }
+            }));
 
+            // If a quote string is provided, try to highlight the exact reference text
+            if (text && typeof text === 'string') {
+              const normalized = text.replace(/\s+/g, ' ').trim();
+              if (normalized.length >= 8) {
+                window.dispatchEvent(new CustomEvent('tutor-highlight-quote', {
+                  detail: { text: normalized, page }
+                }));
+              }
+            }
+          }
+          
+          return { 
+            success: true, 
+            annotation,
+            message: `Created ${type} annotation on page ${page}${text ? `: ${text}` : ''}` 
+          };
+        }
+      }),
+
+      tool({
+        name: 'list_sections',
+        description: 'Return the list of detected document sections (title and page) from the viewer',
+        parameters: { type: 'object', properties: {}, required: [], additionalProperties: false },
+        execute: async () => {
+          if (typeof window !== 'undefined') {
+            const outline = (window as any).__pdfOutline || [];
+            return { success: true, sections: outline.map((s: any) => ({ title: s.title, page: s.pageIndex + 1 })) };
+          }
+          return { success: false, sections: [] };
+        }
+      }),
+
+      tool({
+        name: 'navigate_to_section',
+        description: 'Navigate to a section by number (e.g., 5.1) or title (e.g., Baselines). Also highlights the section title.',
+        parameters: {
+          type: 'object',
+          properties: { query: { type: 'string', description: 'Section number or title' } },
+          required: ['query'],
+          additionalProperties: false
+        },
+        execute: async (input: any) => {
+          const qRaw = String(input?.query || '').trim();
+          if (!qRaw) return { success: false, message: 'Missing section query' };
+          if (typeof window === 'undefined') return { success: false, message: 'Not in browser context' };
+          const outline: Array<{ title: string; pageIndex: number }> = (window as any).__pdfOutline || [];
+          const q = qRaw.toLowerCase();
+          const normalize = (s: string) => s.toLowerCase().replace(/\s+/g, ' ').trim();
+          const numLike = q.match(/^\d+(?:\.\d+)*$/);
+          let match = null as any;
+          if (numLike) {
+            match = outline.find((s) => normalize(s.title).startsWith(q));
+          }
+          if (!match) {
+            match = outline.find((s) => normalize(s.title).includes(q) || q.includes(normalize(s.title)));
+          }
+          if (match) {
+            try { (window as any).pdfJumpToPage ? (window as any).pdfJumpToPage(match.pageIndex + 1) : window.dispatchEvent(new CustomEvent('pdf-navigate-page', { detail: { pageNumber: match.pageIndex } })); } catch {}
+            const requestId = `section-nav-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+            window.dispatchEvent(new CustomEvent('pdf-search-request', { detail: { requestId, keywords: [{ keyword: match.title, matchCase: false }] } }));
+            return { success: true, page: match.pageIndex + 1, section: match.title };
+          }
+          // fallback: search for the query text directly
+          const requestId = `section-fallback-${Date.now()}-${Math.random().toString(36).slice(2)}`;
+          window.dispatchEvent(new CustomEvent('pdf-search-request', { detail: { requestId, keywords: [{ keyword: qRaw, matchCase: false }] } }));
+          return { success: false, message: 'Section not found in outline; highlighted search results instead.' };
+        }
+      })
+    ]
+  });
+};
\ No newline at end of file
diff --git a/src/lib/auth.ts b/src/lib/auth.ts
index 7bb88a1..5cdf420 100644
--- a/src/lib/auth.ts
+++ b/src/lib/auth.ts
@@ -1,17 +1,12 @@
 import NextAuth from 'next-auth'
-import Passkey from 'next-auth/providers/passkey'
-import { PrismaAdapter } from '@auth/prisma-adapter'
-import { prisma } from './prisma'
 import type { Session, User } from 'next-auth'
 import type { JWT } from 'next-auth/jwt'
 import CredentialsProvider from 'next-auth/providers/credentials'
 import bcrypt from 'bcryptjs'
+import { prisma } from './prisma'
 
 const authConfig = {
-  trustHost: true,
-  adapter: PrismaAdapter(prisma) as any,
   providers: [
-    Passkey,
     CredentialsProvider({
       id: 'credentials',
       name: 'credentials',
@@ -36,7 +31,6 @@ const authConfig = {
   ],
   session: { strategy: 'jwt' },
   pages: { signIn: '/auth/signin' },
-  experimental: { enableWebAuthn: true } as any,
   callbacks: {
     async jwt({ token, user }: { token: JWT; user?: User | null }) {
       if (user) (token as any).id = (user as any).id
diff --git a/src/lib/pdfUtils.ts b/src/lib/pdfUtils.ts
index 6388a79..a92d2e7 100644
--- a/src/lib/pdfUtils.ts
+++ b/src/lib/pdfUtils.ts
@@ -10,90 +10,6 @@ export interface PDFExtractionResult {
   numPages?: number
 }
 
-export function extractTitleCandidates(text: string): string[] {
-  if (!text) return [];
-  const lines = text
-    .split('\n')
-    .slice(0, 40)
-    .map((l) => l.trim())
-    .filter(Boolean);
-  const bad = /(submitted to|interspeech|arxiv|preprint|proceedings|workshop|conference|copyright|license|doi|http|www|university|department|school|laboratory|affiliation)/i;
-  const named = /^(abstract|introduction|background|related\s+work|methods?|approach|experiments?|results|discussion|conclusions?|references|appendix|baselines?)\b/i;
-  return lines
-    .filter((l) => l.length >= 8 && l.length <= 160)
-    .filter((l) => /[a-zA-Z]/.test(l))
-    .filter((l) => /^[A-Z]/.test(l))
-    .filter((l) => !bad.test(l))
-    .filter((l) => !named.test(l))
-    .filter((l) => !/[.:]$/.test(l))
-    .filter((l) => l.split(/\s+/).length >= 3)
-    .filter((l) => l !== l.toUpperCase());
-}
-
-export function extractLikelyTitle(text: string): string | undefined {
-  const candidates = extractTitleCandidates(text);
-  return candidates[0];
-}
-
-export function extractAuthorCandidates(text: string, title?: string): string[] {
-  if (!text) return []
-  const lines = text.split('\n').slice(0, 60).map(l => l.trim())
-  // If we know the title, start looking just after it
-  let startIdx = 0
-  if (title) {
-    const idx = lines.findIndex(l => l === title)
-    if (idx >= 0) startIdx = Math.min(idx + 1, lines.length - 1)
-  }
-
-  // Consider a small window after the title
-  const windowLines = lines.slice(startIdx, startIdx + 10)
-  // Join consecutive non-empty lines until a blank appears
-  let block: string[] = []
-  for (const l of windowLines) {
-    if (!l) break
-    // skip venue/footer style lines
-    if (/(submitted to|interspeech|arxiv|preprint|proceedings)/i.test(l)) continue
-    block.push(l)
-    // stop early if we collected enough text
-    if (block.join(' ').length > 200) break
-  }
-  const merged = block.join(' ')
-
-  // Strip emails, affiliations markers, and footnote symbols
-  let cleaned = merged
-    .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, ' ')
-    .replace(/\d+|\*|†|‡|§|¶|‖|‗|\^/g, ' ')
-    .replace(/\s+/g, ' ')
-    .trim()
-
-  // Extract sequences of capitalized names separated by commas/and
-  // Example: "Yassir Fathullah, Chunyang Wu, Yuan Sun and Jane O'Connor"
-  const namePattern = /([A-Z][A-Za-z'\-]+(?:\s+[A-Z][A-Za-z'\-]+){0,3})/g
-  const rawParts = cleaned.split(/\s+(?:and|&|,|;|\band\b)\s+/i)
-  const candidates: string[] = []
-  for (const part of rawParts) {
-    const m = part.match(namePattern)
-    if (m && m.length) {
-      const candidate = m.join(' ').trim()
-      // Heuristic: at least two words, not all caps, reasonable length
-      const wc = candidate.split(/\s+/).length
-      if (wc >= 2 && wc <= 5 && candidate !== candidate.toUpperCase()) {
-        candidates.push(candidate)
-      }
-    }
-  }
-  // Deduplicate while preserving order
-  const seen = new Set<string>()
-  return candidates.filter(n => (seen.has(n) ? false : (seen.add(n), true)))
-}
-
-export function extractLikelyAuthors(text: string, title?: string): string | undefined {
-  const names = extractAuthorCandidates(text, title)
-  if (names.length === 0) return undefined
-  // Join top few names
-  return names.slice(0, 8).join(', ')
-}
-
 export async function extractTextFromPDF(filePath: string): Promise<PDFExtractionResult> {
   try {
     let dataBuffer: Buffer
@@ -143,26 +59,29 @@ export async function extractTextFromPDF(filePath: string): Promise<PDFExtractio
       keywords: data.info?.Keywords ? data.info.Keywords.split(',').map((k: string) => k.trim()) : undefined,
       numPages: data.numpages || undefined
     }
-
-    // If metadata title is a venue/submission marker, discard it so we can extract a real title from text
-    const badMetaTitle = /(submitted to|interspeech|arxiv|preprint|proceedings|workshop|conference)/i
-    if (result.title && badMetaTitle.test(result.title)) {
-      result.title = undefined
-    }
     
-    // If no title in metadata, try to extract from the first few lines of text with stricter heuristics
+    // If no title in metadata, try to extract from first few lines of text
     if (!result.title && result.text) {
-      const first = extractTitleCandidates(result.text)[0]
-      if (first) result.title = first
-    }
-
-    // Author extraction: prefer metadata unless it's generic/noisy; otherwise parse from text
-    const badAuthor = /(withheld|anonymous|n\/?a|not available)/i
-    if ((!result.author || badAuthor.test(String(result.author))) && result.text) {
-      const parsedAuthors = extractLikelyAuthors(result.text, result.title)
-      if (parsedAuthors) result.author = parsedAuthors
+      const lines = result.text.split('\n').slice(0, 10); // Check first 10 lines
+      for (const line of lines) {
+        const trimmedLine = line.trim();
+        // Look for lines that could be titles (not too long, starts with capital, not empty)
+        if (trimmedLine.length > 3 && 
+            trimmedLine.length < 200 && 
+            /^[A-Z]/.test(trimmedLine) && 
+            !trimmedLine.includes('Abstract') &&
+            !trimmedLine.includes('Introduction') &&
+            !trimmedLine.includes('Table of Contents') &&
+            !trimmedLine.includes('References') &&
+            !trimmedLine.includes('Bibliography') &&
+            !trimmedLine.includes('Chapter') &&
+            !trimmedLine.includes('Section')) {
+          result.title = trimmedLine;
+          break;
+        }
+      }
     }
-
+    
     console.log("📄 PDF extraction result:", {
       textLength: result.text.length,
       title: result.title,
diff --git a/yarn.lock b/yarn.lock
index 61e4f83..67fc7dc 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -42,19 +42,6 @@
   resolved "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz"
   integrity sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==
 
-"@auth/core@0.26.0":
-  version "0.26.0"
-  resolved "https://registry.yarnpkg.com/@auth/core/-/core-0.26.0.tgz#a0c61412eac159592e78fcb16725ab5b6b9bff15"
-  integrity sha512-AcuOQZHVUJDIbP6l98GttJNlobo3dxFfUiUEzzESapJ5BxJM+k/Cez3heDkQFhDBeati+FDZpZb4aPtH+odNwA==
-  dependencies:
-    "@panva/hkdf" "^1.1.1"
-    "@types/cookie" "0.6.0"
-    cookie "0.6.0"
-    jose "^5.1.3"
-    oauth4webapi "^2.4.0"
-    preact "10.11.3"
-    preact-render-to-string "5.2.3"
-
 "@auth/core@0.40.0", "@auth/core@^0.40.0":
   version "0.40.0"
   resolved "https://registry.npmjs.org/@auth/core/-/core-0.40.0.tgz"
@@ -66,12 +53,12 @@
     preact "10.24.3"
     preact-render-to-string "6.5.11"
 
-"@auth/prisma-adapter@1.3.0":
-  version "1.3.0"
-  resolved "https://registry.yarnpkg.com/@auth/prisma-adapter/-/prisma-adapter-1.3.0.tgz#1c8e23dfd66562959a502b1b86d600b7d3efe8a4"
-  integrity sha512-D7WTD/KNXeuIPsZwV0sctv9CDLV5DKBw5sa7mS5L6AZ9nP2OEkbf5Xe61KgzqpB9C9Tz/dbcpWStaKdmFqvyxQ==
+"@auth/prisma-adapter@^2.10.0":
+  version "2.10.0"
+  resolved "https://registry.npmjs.org/@auth/prisma-adapter/-/prisma-adapter-2.10.0.tgz"
+  integrity sha512-EliOQoTjGK87jWWqnJvlQjbR4PjQZQqtwRwPAe108WwT9ubuuJJIrL68aNnQr4hFESz6P7SEX2bZy+y2yL37Gw==
   dependencies:
-    "@auth/core" "0.26.0"
+    "@auth/core" "0.40.0"
 
 "@babel/runtime@^7.12.5", "@babel/runtime@^7.23.2":
   version "7.28.3"
@@ -301,11 +288,6 @@
   resolved "https://registry.npmjs.org/@fastify/busboy/-/busboy-2.1.1.tgz"
   integrity sha512-vBZP4NlzfOlerQTnba4aqZoMhE/a9HY7HRqoOPaETQcSQuWEIyZMHGfVu6w9wGtGK5fED5qRs2DteVCjOH60sA==
 
-"@hexagon/base64@^1.1.27":
-  version "1.1.28"
-  resolved "https://registry.yarnpkg.com/@hexagon/base64/-/base64-1.1.28.tgz#7d306a97f1423829be5b27c9d388fe50e3099d48"
-  integrity sha512-lhqDEAvWixy3bZ+UOYbPwUbBkwBq5C1LAJ/xPC8Oi+lL54oyakv/npbA0aU2hgCsx/1NUd4IBvV03+aUBWxerw==
-
 "@humanfs/core@^0.19.1":
   version "0.19.1"
   resolved "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz"
@@ -514,11 +496,6 @@
     "@jridgewell/resolve-uri" "^3.1.0"
     "@jridgewell/sourcemap-codec" "^1.4.14"
 
-"@levischuck/tiny-cbor@^0.2.2":
-  version "0.2.11"
-  resolved "https://registry.yarnpkg.com/@levischuck/tiny-cbor/-/tiny-cbor-0.2.11.tgz#833ddf7f3627dcb62d855d9c184061b4a1a875b3"
-  integrity sha512-llBRm4dT4Z89aRsm6u2oEZ8tfwL/2l6BwpZ7JcyieouniDECM5AqNgr/y08zalEIvW3RSK4upYyybDcmjXqAow==
-
 "@mapbox/node-pre-gyp@^1.0.0":
   version "1.0.11"
   resolved "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz"
@@ -692,59 +669,11 @@
   resolved "https://registry.npmjs.org/@opentelemetry/api/-/api-1.9.0.tgz"
   integrity sha512-3giAOQvZiH5F9bMlMiv8+GSPMeqg0dbaeo58/0SlA9sxSqZhnUtxzX9/2FzyhS9sWQf5S0GJE0AKBrFqjpeYcg==
 
-"@panva/hkdf@^1.1.1", "@panva/hkdf@^1.2.1":
+"@panva/hkdf@^1.2.1":
   version "1.2.1"
   resolved "https://registry.npmjs.org/@panva/hkdf/-/hkdf-1.2.1.tgz"
   integrity sha512-6oclG6Y3PiDFcoyk8srjLfVKyMfVCKJ27JwNPViuXziFpmdz+MZnZN/aKY0JGXgYuO/VghU0jcOAZgWXZ1Dmrw==
 
-"@peculiar/asn1-android@^2.3.10":
-  version "2.5.0"
-  resolved "https://registry.yarnpkg.com/@peculiar/asn1-android/-/asn1-android-2.5.0.tgz#039c3b08dbd80cfb9b4c7f239c43a91247b58f98"
-  integrity sha512-t8A83hgghWQkcneRsgGs2ebAlRe54ns88p7ouv8PW2tzF1nAW4yHcL4uZKrFpIU+uszIRzTkcCuie37gpkId0A==
-  dependencies:
-    "@peculiar/asn1-schema" "^2.5.0"
-    asn1js "^3.0.6"
-    tslib "^2.8.1"
-
-"@peculiar/asn1-ecc@^2.3.8":
-  version "2.5.0"
-  resolved "https://registry.yarnpkg.com/@peculiar/asn1-ecc/-/asn1-ecc-2.5.0.tgz#3bbeaa3443567055be112b4c7e9d5562951242cf"
-  integrity sha512-t4eYGNhXtLRxaP50h3sfO6aJebUCDGQACoeexcelL4roMFRRVgB20yBIu2LxsPh/tdW9I282gNgMOyg3ywg/mg==
-  dependencies:
-    "@peculiar/asn1-schema" "^2.5.0"
-    "@peculiar/asn1-x509" "^2.5.0"
-    asn1js "^3.0.6"
-    tslib "^2.8.1"
-
-"@peculiar/asn1-rsa@^2.3.8":
-  version "2.5.0"
-  resolved "https://registry.yarnpkg.com/@peculiar/asn1-rsa/-/asn1-rsa-2.5.0.tgz#7283756ec596ccfbef23ff0e7eda0c37133ebed8"
-  integrity sha512-qMZ/vweiTHy9syrkkqWFvbT3eLoedvamcUdnnvwyyUNv5FgFXA3KP8td+ATibnlZ0EANW5PYRm8E6MJzEB/72Q==
-  dependencies:
-    "@peculiar/asn1-schema" "^2.5.0"
-    "@peculiar/asn1-x509" "^2.5.0"
-    asn1js "^3.0.6"
-    tslib "^2.8.1"
-
-"@peculiar/asn1-schema@^2.3.8", "@peculiar/asn1-schema@^2.5.0":
-  version "2.5.0"
-  resolved "https://registry.yarnpkg.com/@peculiar/asn1-schema/-/asn1-schema-2.5.0.tgz#4e58d7c3087c4259cebf5363e092f85b9cbf0ca1"
-  integrity sha512-YM/nFfskFJSlHqv59ed6dZlLZqtZQwjRVJ4bBAiWV08Oc+1rSd5lDZcBEx0lGDHfSoH3UziI2pXt2UM33KerPQ==
-  dependencies:
-    asn1js "^3.0.6"
-    pvtsutils "^1.3.6"
-    tslib "^2.8.1"
-
-"@peculiar/asn1-x509@^2.3.8", "@peculiar/asn1-x509@^2.5.0":
-  version "2.5.0"
-  resolved "https://registry.yarnpkg.com/@peculiar/asn1-x509/-/asn1-x509-2.5.0.tgz#305f9cd534f4b6a723d27fc59363f382debf5500"
-  integrity sha512-CpwtMCTJvfvYTFMuiME5IH+8qmDe3yEWzKHe7OOADbGfq7ohxeLaXwQo0q4du3qs0AII3UbLCvb9NF/6q0oTKQ==
-  dependencies:
-    "@peculiar/asn1-schema" "^2.5.0"
-    asn1js "^3.0.6"
-    pvtsutils "^1.3.6"
-    tslib "^2.8.1"
-
 "@prisma/client@^6.14.0":
   version "6.14.0"
   resolved "https://registry.npmjs.org/@prisma/client/-/client-6.14.0.tgz"
@@ -1081,33 +1010,6 @@
   resolved "https://registry.npmjs.org/@rushstack/eslint-patch/-/eslint-patch-1.12.0.tgz"
   integrity sha512-5EwMtOqvJMMa3HbmxLlF74e+3/HhwBTMcvt3nqVJgGCozO6hzIPOBlwm8mGVNR9SN2IJpxSnlxczyDjcn7qIyw==
 
-"@simplewebauthn/browser@9.0.1":
-  version "9.0.1"
-  resolved "https://registry.yarnpkg.com/@simplewebauthn/browser/-/browser-9.0.1.tgz#46a12c2bcefcb199f7fcb6a7e883531cd6efde17"
-  integrity sha512-wD2WpbkaEP4170s13/HUxPcAV5y4ZXaKo1TfNklS5zDefPinIgXOpgz1kpEvobAsaLPa2KeH7AKKX/od1mrBJw==
-  dependencies:
-    "@simplewebauthn/types" "^9.0.1"
-
-"@simplewebauthn/server@9.0.3":
-  version "9.0.3"
-  resolved "https://registry.yarnpkg.com/@simplewebauthn/server/-/server-9.0.3.tgz#5f73c19ff2420be94cc71a49085879c111d7872d"
-  integrity sha512-FMZieoBosrVLFxCnxPFD9Enhd1U7D8nidVDT4MsHc6l4fdVcjoeHjDueeXCloO1k5O/fZg1fsSXXPKbY2XTzDA==
-  dependencies:
-    "@hexagon/base64" "^1.1.27"
-    "@levischuck/tiny-cbor" "^0.2.2"
-    "@peculiar/asn1-android" "^2.3.10"
-    "@peculiar/asn1-ecc" "^2.3.8"
-    "@peculiar/asn1-rsa" "^2.3.8"
-    "@peculiar/asn1-schema" "^2.3.8"
-    "@peculiar/asn1-x509" "^2.3.8"
-    "@simplewebauthn/types" "^9.0.1"
-    cross-fetch "^4.0.0"
-
-"@simplewebauthn/types@^9.0.1":
-  version "9.0.1"
-  resolved "https://registry.yarnpkg.com/@simplewebauthn/types/-/types-9.0.1.tgz#3a68d50e63d8821cf2067de3324c68d5e8120d0c"
-  integrity sha512-tGSRP1QvsAvsJmnOlRQyw/mvK9gnPtjEc5fg2+m8n+QUa+D7rvrKkOYyfpy42GTs90X3RDOnqJgfHt+qO67/+w==
-
 "@standard-schema/spec@^1.0.0":
   version "1.0.0"
   resolved "https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0.tgz"
@@ -1244,11 +1146,6 @@
   resolved "https://registry.npmjs.org/@types/bcryptjs/-/bcryptjs-2.4.6.tgz"
   integrity sha512-9xlo6R2qDs5uixm0bcIqCeMCE6HiQsIyel9KQySStiyqNl2tnj2mP3DX1Nf56MD6KMenNNlBBsy3LJ7gUEQPXQ==
 
-"@types/cookie@0.6.0":
-  version "0.6.0"
-  resolved "https://registry.yarnpkg.com/@types/cookie/-/cookie-0.6.0.tgz#eac397f28bf1d6ae0ae081363eca2f425bedf0d5"
-  integrity sha512-4Kh9a6B2bQciAhf7FSuMRRkUWecJgJu9nPnx3yzpsfXX/c50REIqpHY4C82bXP90qrLtXtkDxTZosYO3UpOwlA==
-
 "@types/debug@^4.0.0":
   version "4.1.12"
   resolved "https://registry.npmjs.org/@types/debug/-/debug-4.1.12.tgz"
@@ -1790,15 +1687,6 @@ arraybuffer.prototype.slice@^1.0.4:
     get-intrinsic "^1.2.6"
     is-array-buffer "^3.0.4"
 
-asn1js@^3.0.6:
-  version "3.0.6"
-  resolved "https://registry.yarnpkg.com/asn1js/-/asn1js-3.0.6.tgz#53e002ebe00c5f7fd77c1c047c3557d7c04dce25"
-  integrity sha512-UOCGPYbl0tv8+006qks/dTgV9ajs97X2p0FAbyS2iyCRrmLSRolDaHdp+v/CLgnzHc3fVB+CwYiUmei7ndFcgA==
-  dependencies:
-    pvtsutils "^1.3.6"
-    pvutils "^1.1.3"
-    tslib "^2.8.1"
-
 ast-types-flow@^0.0.8:
   version "0.0.8"
   resolved "https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.8.tgz"
@@ -2153,11 +2041,6 @@ cookie-signature@^1.2.1:
   resolved "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz"
   integrity sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==
 
-cookie@0.6.0:
-  version "0.6.0"
-  resolved "https://registry.yarnpkg.com/cookie/-/cookie-0.6.0.tgz#2798b04b071b0ecbff0dbb62a505a8efa4e19051"
-  integrity sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==
-
 cookie@^0.7.1:
   version "0.7.2"
   resolved "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz"
@@ -2176,13 +2059,6 @@ cors@^2.8.5:
     object-assign "^4"
     vary "^1"
 
-cross-fetch@^4.0.0:
-  version "4.1.0"
-  resolved "https://registry.yarnpkg.com/cross-fetch/-/cross-fetch-4.1.0.tgz#8f69355007ee182e47fa692ecbaa37a52e43c3d2"
-  integrity sha512-uKm5PU+MHTootlWEY+mZ4vvXoCn4fLQxT9dSc1sXVMSFkINTJVN8cAQROpwcKm8bJ/c7rgZVIBWzH5T78sNZZw==
-  dependencies:
-    node-fetch "^2.7.0"
-
 cross-spawn@^7.0.5, cross-spawn@^7.0.6:
   version "7.0.6"
   resolved "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz"
@@ -3632,11 +3508,6 @@ jiti@^2.4.2, jiti@^2.5.1:
   resolved "https://registry.npmjs.org/jiti/-/jiti-2.5.1.tgz"
   integrity sha512-twQoecYPiVA5K/h6SxtORw/Bs3ar+mLUtoPSc7iMXzQzK8d7eJ/R09wmTwAjiamETn1cXYPGfNnu7DMoHgu12w==
 
-jose@^5.1.3:
-  version "5.10.0"
-  resolved "https://registry.yarnpkg.com/jose/-/jose-5.10.0.tgz#c37346a099d6467c401351a9a0c2161e0f52c4be"
-  integrity sha512-s+3Al/p9g32Iq+oqXxkW//7jk2Vig6FF1CFqzVXoTUXt2qz89YWbL+OwS17NFYEvxC35n0FKeGO2LGYSxeM2Gg==
-
 jose@^6.0.6:
   version "6.0.12"
   resolved "https://registry.npmjs.org/jose/-/jose-6.0.12.tgz"
@@ -4411,7 +4282,7 @@ node-fetch-native@^1.6.6:
   resolved "https://registry.npmjs.org/node-fetch-native/-/node-fetch-native-1.6.7.tgz"
   integrity sha512-g9yhqoedzIUm0nTnTqAQvueMPVOuIY16bqgAJJC8XOOubYFNwz6IER9qs0Gq2Xd0+CecCKFjtdDTMA4u4xG06Q==
 
-node-fetch@^2.6.7, node-fetch@^2.7.0:
+node-fetch@^2.6.7:
   version "2.7.0"
   resolved "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz"
   integrity sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==
@@ -4446,11 +4317,6 @@ nypm@^0.6.0:
     pkg-types "^2.2.0"
     tinyexec "^1.0.1"
 
-oauth4webapi@^2.4.0:
-  version "2.17.0"
-  resolved "https://registry.yarnpkg.com/oauth4webapi/-/oauth4webapi-2.17.0.tgz#4af65bd4dac6761d8e4f2fb20848e82a879a6725"
-  integrity sha512-lbC0Z7uzAFNFyzEYRIC+pkSVvDHJTbEW+dYlSBAlCYDe6RxUkJ26bClhk8ocBZip1wfI9uKTe0fm4Ib4RHn6uQ==
-
 oauth4webapi@^3.3.0:
   version "3.7.0"
   resolved "https://registry.npmjs.org/oauth4webapi/-/oauth4webapi-3.7.0.tgz"
@@ -4738,23 +4604,11 @@ postcss@^8.4.41:
     picocolors "^1.1.1"
     source-map-js "^1.2.1"
 
-preact-render-to-string@5.2.3:
-  version "5.2.3"
-  resolved "https://registry.yarnpkg.com/preact-render-to-string/-/preact-render-to-string-5.2.3.tgz#23d17376182af720b1060d5a4099843c7fe92fe4"
-  integrity sha512-aPDxUn5o3GhWdtJtW0svRC2SS/l8D9MAgo2+AWml+BhDImb27ALf04Q2d+AHqUUOc6RdSXFIBVa2gxzgMKgtZA==
-  dependencies:
-    pretty-format "^3.8.0"
-
 preact-render-to-string@6.5.11:
   version "6.5.11"
   resolved "https://registry.npmjs.org/preact-render-to-string/-/preact-render-to-string-6.5.11.tgz"
   integrity sha512-ubnauqoGczeGISiOh6RjX0/cdaF8v/oDXIjO85XALCQjwQP+SB4RDXXtvZ6yTYSjG+PC1QRP2AhPgCEsM2EvUw==
 
-preact@10.11.3:
-  version "10.11.3"
-  resolved "https://registry.yarnpkg.com/preact/-/preact-10.11.3.tgz#8a7e4ba19d3992c488b0785afcc0f8aa13c78d19"
-  integrity sha512-eY93IVpod/zG3uMF22Unl8h9KkrcKIRs2EGar8hwLZZDU1lkjph303V9HZBwufh2s736U6VXuhD109LYqPoffg==
-
 preact@10.24.3:
   version "10.24.3"
   resolved "https://registry.npmjs.org/preact/-/preact-10.24.3.tgz"
@@ -4765,16 +4619,6 @@ prelude-ls@^1.2.1:
   resolved "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz"
   integrity sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==
 
-prettier@^3.6.2:
-  version "3.6.2"
-  resolved "https://registry.yarnpkg.com/prettier/-/prettier-3.6.2.tgz#ccda02a1003ebbb2bfda6f83a074978f608b9393"
-  integrity sha512-I7AIg5boAr5R0FFtJ6rCfD+LFsWHp81dolrFD8S79U9tb8Az2nGrJncnMSnys+bpQJfRUzqs9hnA81OAA3hCuQ==
-
-pretty-format@^3.8.0:
-  version "3.8.0"
-  resolved "https://registry.yarnpkg.com/pretty-format/-/pretty-format-3.8.0.tgz#bfbed56d5e9a776645f4b1ff7aa1a3ac4fa3c385"
-  integrity sha512-WuxUnVtlWL1OfZFQFuqvnvs6MiAGk9UNsBostyBOB0Is9wb5uRESevA6rnl/rkksXaGX3GzZhPup5d6Vp1nFew==
-
 prisma@^6.14.0:
   version "6.14.0"
   resolved "https://registry.npmjs.org/prisma/-/prisma-6.14.0.tgz"
@@ -4815,18 +4659,6 @@ pure-rand@^6.1.0:
   resolved "https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz"
   integrity sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==
 
-pvtsutils@^1.3.6:
-  version "1.3.6"
-  resolved "https://registry.yarnpkg.com/pvtsutils/-/pvtsutils-1.3.6.tgz#ec46e34db7422b9e4fdc5490578c1883657d6001"
-  integrity sha512-PLgQXQ6H2FWCaeRak8vvk1GW462lMxB5s3Jm673N82zI4vqtVUPuZdffdZbPDFRoU8kAhItWFtPCWiPpp4/EDg==
-  dependencies:
-    tslib "^2.8.1"
-
-pvutils@^1.1.3:
-  version "1.1.3"
-  resolved "https://registry.yarnpkg.com/pvutils/-/pvutils-1.1.3.tgz#f35fc1d27e7cd3dfbd39c0826d173e806a03f5a3"
-  integrity sha512-pMpnA0qRdFp32b1sJl1wOJNxZLQ2cbQx+k6tjNtZ8CpvVhNqEPRgivZ2WOUev2YMajecdH7ctUPDvEe87nariQ==
-
 qs@^6.14.0:
   version "6.14.0"
   resolved "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz"
@@ -5572,7 +5404,7 @@ tsconfig-paths@^3.15.0:
     minimist "^1.2.6"
     strip-bom "^3.0.0"
 
-tslib@^2.4.0, tslib@^2.8.0, tslib@^2.8.1:
+tslib@^2.4.0, tslib@^2.8.0:
   version "2.8.1"
   resolved "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz"
   integrity sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==
